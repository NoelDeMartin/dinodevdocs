"use strict";(self.webpackChunkdevdocs=self.webpackChunkdevdocs||[]).push([[92307],{61024:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>u});var s=t(74848),n=t(28453),r=t(78924);const o={title:"Favourites API",tags:["API","core_favourites"]},a=void 0,c={id:"apis/subsystems/favourites/index",title:"Favourites API",description:"Overview",source:"@site/versioned_docs/version-4.2/apis/subsystems/favourites/index.md",sourceDirName:"apis/subsystems/favourites",slug:"/apis/subsystems/favourites/",permalink:"/moodledevdocs/docs/4.2/apis/subsystems/favourites/",draft:!1,unlisted:!1,editUrl:"https://github.com/moodle/devdocs/edit/main/versioned_docs/version-4.2/apis/subsystems/favourites/index.md",tags:[{label:"API",permalink:"/moodledevdocs/docs/4.2/tags/api"},{label:"core_favourites",permalink:"/moodledevdocs/docs/4.2/tags/core-favourites"}],version:"4.2",lastUpdatedBy:"Andrew Nicols",lastUpdatedAt:171272905e4,frontMatter:{title:"Favourites API",tags:["API","core_favourites"]},sidebar:"docs",previous:{title:"Unit Testing",permalink:"/moodledevdocs/docs/4.2/apis/subsystems/external/testing"},next:{title:"File API",permalink:"/moodledevdocs/docs/4.2/apis/subsystems/files/"}},d={},u=[{value:"Overview",id:"overview",level:2},{value:"What is a favourite?",id:"what-is-a-favourite",level:3},{value:"What can be marked as a favourite?",id:"what-can-be-marked-as-a-favourite",level:3},{value:"Identifying items",id:"identifying-items",level:3},{value:"Using the API",id:"using-the-api",level:2},{value:"Getting a service object",id:"getting-a-service-object",level:3},{value:"Creating a favourite",id:"creating-a-favourite",level:3},{value:"Reading favourites",id:"reading-favourites",level:3},{value:"Deleting a favourite",id:"deleting-a-favourite",level:3},{value:"Including favourites in external queries",id:"including-favourites-in-external-queries",level:3}];function l(e){const i={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.A,{frontMatter:o,metadata:c}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(i.h3,{id:"what-is-a-favourite",children:"What is a favourite?"}),"\n",(0,s.jsx)(i.p,{children:"The favourites API allows you to mark items as favourites for a given user. Marking an item as a favourite is akin to adding a web page to your browser favourites (or bookmarks), or marking someone in your contacts as a favourite. The API provides a means to create, read and delete favourite items, allowing any component to favourite arbitrary items as they see fit."}),"\n",(0,s.jsx)(i.h3,{id:"what-can-be-marked-as-a-favourite",children:"What can be marked as a favourite?"}),"\n",(0,s.jsx)(i.p,{children:"Almost any 'item' can be marked as a favourite, provided it is something which can be identified by a unique integer id."}),"\n",(0,s.jsx)(i.h3,{id:"identifying-items",children:"Identifying items"}),"\n",(0,s.jsxs)(i.p,{children:["In order to store a favourite, and be able to uniquely identify it for later retrieval, 4 fields are required. These are: ",(0,s.jsx)(i.strong,{children:"component"}),", ",(0,s.jsx)(i.strong,{children:"itemtype"}),", ",(0,s.jsx)(i.strong,{children:"itemid"})," and ",(0,s.jsx)(i.strong,{children:"contextid"}),". You will see these in a range of API calls."]}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.strong,{children:"itemid"})," is a unique integer identifier of the item itself. This might be a course id, or conversation id, or the id of any entity in Moodle. In fact, it does not have to be the id of a record from the database either; it can be any arbitrary id, so long as the component storing the item knows what it represents."]}),"\n",(0,s.jsxs)(i.p,{children:["The two fields ",(0,s.jsx)(i.strong,{children:"component"})," and ",(0,s.jsx)(i.strong,{children:"itemtype"})," make up a pairing representing the ",(0,s.jsx)(i.em,{children:"type"})," of each favourite. Within this pair, the ",(0,s.jsx)(i.strong,{children:"component"})," must be a valid ",(0,s.jsx)(i.a,{href:"/general/development/policies/codingstyle/frankenstyle",children:"frankenstyle"})," component name and is the name of the component wishing to set/unset the item as a favourite. The ",(0,s.jsx)(i.strong,{children:"itemtype"})," can be any identifying string, provided it is unique within the respective component. The type pairing allows us to distinguish between favourites of different types (from different areas of Moodle), which may have identical itemid values."]}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.strong,{children:"contextid"})," is the id of the context in which the item is being marked as a favourite. For example, a user's course might be marked as a favourite at the course context, whereas a user's conversation with another user might be marked as a favourite at the user context. It's also possible that items of a certain ",(0,s.jsx)(i.em,{children:"type"})," (remember, this is the ",(0,s.jsx)(i.code,{children:"{component, itemtype}"})," pairing) will be marked as favourites in different contexts, based on the context of the item itself. For example, consider the case in messaging, in which we have a group conversation (one which is linked to a course group), and an individual conversation between two users. Setting the group conversation as a favourite would require the course context to be used, whereas doing the same for the individual conversation would require a user context. Which contextid to use is a decision that must be made by the component creating the favourite."]}),"\n",(0,s.jsx)(i.h2,{id:"using-the-api",children:"Using the API"}),"\n",(0,s.jsx)(i.h3,{id:"getting-a-service-object",children:"Getting a service object"}),"\n",(0,s.jsx)(i.p,{children:"Favourites relies on a service layer to provide functionality to consumers. Getting a service object is as simple as using the service factory methods."}),"\n",(0,s.jsx)(i.p,{children:"Assuming you have a user context, you can get a service scoped to a single user with:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-php",children:"$ufservice = \\core_favourites\\service_factory::get_service_for_user_context($usercontext);\n"})}),"\n",(0,s.jsxs)(i.p,{children:["The returned ",(0,s.jsx)(i.code,{children:"$ufservice"})," is an object of type \\core_favourites\\local\\service\\user_favourite_service."]}),"\n",(0,s.jsx)(i.h3,{id:"creating-a-favourite",children:"Creating a favourite"}),"\n",(0,s.jsxs)(i.p,{children:["Let's say we want to set a course as a favourite. Note: In core, this is done by using the favourite ",(0,s.jsx)(i.em,{children:"type"})," ","courses","."]}),"\n",(0,s.jsx)(i.p,{children:"The service provides the method:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-php",children:"public function create_favourite(\n    string $component,\n    string $itemtype,\n    int $itemid,\n    \\context $context,\n    int $ordering = null\n): favourite;\n"})}),"\n",(0,s.jsx)(i.p,{children:"So, assuming we have the course id and course context, we can create our favourite with:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-php",children:"$favourite = $ufservice->create_favourite('core_course', 'courses', $course->id, $coursecontext);\n"})}),"\n",(0,s.jsx)(i.p,{children:"The returned $favourite is an object of type \\core_favourites\\local\\entity\\favourite."}),"\n",(0,s.jsx)(i.h3,{id:"reading-favourites",children:"Reading favourites"}),"\n",(0,s.jsx)(i.p,{children:"There are several read actions supported by the service object."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-php",children:"public function count_favourites_by_type(string $component, string $itemtype, \\context $context = null) : int;\npublic function find_favourites_by_type(string $component, string $itemtype, int $limitfrom = 0, int $limitnum = 0) : array;\npublic function favourite_exists(string $component, string $itemtype, int $itemid, \\context $context) : bool;\npublic function get_favourite(string $component, string $itemtype, int $itemid, \\context $context) : favourite;\n"})}),"\n",(0,s.jsx)(i.h3,{id:"deleting-a-favourite",children:"Deleting a favourite"}),"\n",(0,s.jsx)(i.p,{children:"The service provides the method:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-php",children:"public function delete_favourite(string $component, string $itemtype, int $itemid, \\context $context);\n"})}),"\n",(0,s.jsx)(i.p,{children:"So, assuming we have the course id and course context, we can remove the favourite with:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-php",children:"$ufservice = \\core_favourites\\service_factory::get_service_for_user_context($usercontext);\n$ufservice->delete_favourite('core_course', 'courses', $course->id, $coursecontext);\n"})}),"\n",(0,s.jsx)(i.h3,{id:"including-favourites-in-external-queries",children:"Including favourites in external queries"}),"\n",(0,s.jsx)(i.p,{children:"Most of the time, you should ask the service to find favourite items for you. Sometimes, however, rather than fetching the favourites from the service, you'll just want to include the relevant information in those records from an existing query. You might want to do this if dealing with performance sensitive code where additional queries are undesirable."}),"\n",(0,s.jsx)(i.p,{children:"The service lets you do this too, by providing the method:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-php",children:"public function get_join_sql_by_type(string $component, string $itemtype, string $tablealias, string $joinitemid) : array;\n"})}),"\n",(0,s.jsx)(i.p,{children:"which can be used in such cases."}),"\n",(0,s.jsx)(i.p,{children:"For example, and for simplicity, let's say we have a query returning the ids and names of all courses within a given course category:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-php",children:"$sql = \"SELECT c.id, c.name\n          FROM {course} c\n         WHERE c.category = :category\";\n$params = ['category' => 3];\n\n$courses = $DB->get_records_sql($sql, $params);\n"})}),"\n",(0,s.jsx)(i.p,{children:"we can then modify this using the get_join_sql_by_type() result to include favourite information."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-php",children:"$ufservice = \\core_favourites\\service_factory::get_service_for_user_context($usercontext);\nlist($favsql, $favparams) = $ufservice->get_join_sql_by_type('core_course', 'courses', 'favalias', 'c.id');\n\n$sql = \"SELECT c.id, c.name, favalias.id as favouriteid\n          FROM {course} c\n       $favsql\n         WHERE c.category = :category\";\n$params = ['category' => 3] + $favparams;\n\n$courses = $DB->get_records_sql($sql, $params);\n"})}),"\n",(0,s.jsx)(i.p,{children:"We've now included id of the favourite in the results via a LEFT JOIN, so as to preserve the original set of records."}),"\n",(0,s.jsxs)(i.p,{children:["If you wish to select ONLY favourites, adding ",(0,s.jsx)(i.code,{children:'"AND favouriteid IS NOT NULL"'})," to the query will achieve this."]})]})}function h(e={}){const{wrapper:i}={...(0,n.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);