"use strict";(self.webpackChunkdevdocs=self.webpackChunkdevdocs||[]).push([[92840],{95195:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var s=n(74848),o=n(28453),i=n(78924);const r={title:"Unit testing for the Moodle App",sidebar_label:"Unit testing",sidebar_position:1,tags:["Quality Assurance","Testing","Unit testing","Jest","Moodle App"]},a=void 0,l={id:"app/development/testing/unit-testing",title:"Unit testing for the Moodle App",description:"Unit tests are written in JavaScript using Jest. If you want to create a new one, Jest is already configured and you only need to create a file ending with .test.ts within the project. If you're going to do so, remember to follow the file location conventions.",source:"@site/general/app/development/testing/unit-testing.md",sourceDirName:"app/development/testing",slug:"/app/development/testing/unit-testing",permalink:"/moodledevdocs/general/app/development/testing/unit-testing",draft:!1,unlisted:!1,editUrl:"https://github.com/moodle/devdocs/edit/main/general/app/development/testing/unit-testing.md",tags:[{label:"Quality Assurance",permalink:"/moodledevdocs/general/tags/quality-assurance"},{label:"Testing",permalink:"/moodledevdocs/general/tags/testing"},{label:"Unit testing",permalink:"/moodledevdocs/general/tags/unit-testing"},{label:"Jest",permalink:"/moodledevdocs/general/tags/jest"},{label:"Moodle App",permalink:"/moodledevdocs/general/tags/moodle-app"}],version:"current",lastUpdatedBy:"Noel De Martin",lastUpdatedAt:1713185678e3,sidebarPosition:1,frontMatter:{title:"Unit testing for the Moodle App",sidebar_label:"Unit testing",sidebar_position:1,tags:["Quality Assurance","Testing","Unit testing","Jest","Moodle App"]},sidebar:"moodleapp",previous:{title:"Testing",permalink:"/moodledevdocs/general/app/development/testing/"},next:{title:"Acceptance testing",permalink:"/moodledevdocs/general/app/development/testing/acceptance-testing"}},c={},d=[{value:"Running tests",id:"running-tests",level:2},{value:"Testing plain TypeScript",id:"testing-plain-typescript",level:2},{value:"Testing services",id:"testing-services",level:2},{value:"Testing components",id:"testing-components",level:2},{value:"What about integration tests?",id:"what-about-integration-tests",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.A,{frontMatter:r,metadata:l}),"\n",(0,s.jsxs)(t.p,{children:["Unit tests are written in JavaScript using ",(0,s.jsx)(t.a,{href:"https://jestjs.io/",children:"Jest"}),". If you want to create a new one, Jest is already configured and you only need to create a file ending with ",(0,s.jsx)(t.code,{children:".test.ts"})," within the project. If you're going to do so, remember to follow the ",(0,s.jsx)(t.a,{href:"../development-guide#test-files",children:"file location conventions"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"running-tests",children:"Running tests"}),"\n",(0,s.jsxs)(t.p,{children:["The easiest way to run the entire test suite is to execute the ",(0,s.jsx)(t.code,{children:"npm test"})," command. This will run all the tests in the project. If you want to look at code coverage, you can run ",(0,s.jsx)(t.code,{children:"npm run test:coverage"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["You can also watch changes in your codebase to rerun tests using the ",(0,s.jsx)(t.code,{children:"npm run test:watch"})," command. In combination with the ",(0,s.jsx)(t.code,{children:"--filter"})," flag, you can use this to work on a file while you see how your changes affect the tests. But keep in mind that this will be a partial match. For example, if you are working on ",(0,s.jsx)(t.code,{children:"foobar.ts"})," and you have tests in ",(0,s.jsx)(t.code,{children:"foobar.test.ts"}),", you can run ",(0,s.jsx)(t.code,{children:"npm run test:watch --filter foobar"}),", but this will also run tests from ",(0,s.jsx)(t.code,{children:"foobar-somethingelse.test.ts"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If you are using VSCode, you can use ",(0,s.jsx)(t.a,{href:"https://code.visualstudio.com/Docs/editor/debugging",children:"the built-in debugger"})," to run your tests and stop at breakpoints. The project comes with two tasks preconfigured:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Jest All"})," will run your entire test suite. It's the equivalent of running ",(0,s.jsx)(t.code,{children:"npm test"})," from the command line."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Jest Current File"})," will run the test of the file you have opened in the editor. Like the ",(0,s.jsx)(t.code,{children:"--watch"})," filter, this will be a partial match based on the file name."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"If you are using the default key bindings, these can be re-run automatically pressing the F5 key."}),"\n",(0,s.jsx)(t.h2,{id:"testing-plain-typescript",children:"Testing plain TypeScript"}),"\n",(0,s.jsxs)(t.p,{children:["When you are writing tests, a good part of those will be testing plain TypeScript code. You can use all the ",(0,s.jsx)(t.a,{href:"https://jestjs.io/docs/using-matchers",children:"common techniques used in Jest"}),", and we also offer a couple of helpers."]}),"\n",(0,s.jsxs)(t.p,{children:["If you need to create a mock object, you can use the ",(0,s.jsx)(t.code,{children:"mock"})," helper. This function creates a new object with mock properties and methods. You can use an existing instance, overriding some of its properties and methods if needed, or you can create a new object with only the properties and methods that you want."]}),"\n",(0,s.jsx)(t.p,{children:"For example, let's say we have the following classes:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"class User {\n\n    constructor(public name: string) {}\n\n    greet(): void {\n        // Method implementation\n    }\n\n}\n\nclass Greeter {\n\n    sayHello(user: User): string {\n        user.greet();\n\n        return `${user.name} was greeted.`;\n    }\n\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If you want to write a test for the ",(0,s.jsx)(t.code,{children:"sayHello"})," method, you need an instance of ",(0,s.jsx)(t.code,{children:"User"}),". But maybe you don't want to use a real user because you want to test the ",(0,s.jsx)(t.code,{children:"Greeter"})," class in isolation."]}),"\n",(0,s.jsxs)(t.p,{children:["Using the ",(0,s.jsx)(t.code,{children:"mock"})," helper, you can write the following test:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"it('Greets users', () => {\n    const user = mock<User>({ name: 'John' }, ['greet']);\n    const greeter = new Greeter();\n    const result = greeter.sayHello(user);\n\n    expect(result).toEqual('John was greeted.');\n    expect(user.greet).toHaveBeenCalled();\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Notice how we used the ",(0,s.jsx)(t.code,{children:"mock"})," helper to create a mock that is properly typed as a ",(0,s.jsx)(t.code,{children:"User"}),", we indicated that we want to mock the ",(0,s.jsx)(t.code,{children:"greet"}),' method, and we initialised the mock instance to have a name of "John".']}),"\n",(0,s.jsx)(t.h2,{id:"testing-services",children:"Testing services"}),"\n",(0,s.jsxs)(t.p,{children:["If you are testing some code that uses ",(0,s.jsx)(t.a,{href:"/moodledevdocs/general/app/development/development-guide#service-singletons",children:"Service Singletons"}),", it is likely that you want to mock some of them. You can achieve it by using the ",(0,s.jsx)(t.code,{children:"mockSingleton"})," helper. This method takes a Service Singleton and creates a mock for the instance underneath, mocking the methods and properties that you specify along the way."]}),"\n",(0,s.jsx)(t.p,{children:"For example, let's say that you have the following test:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"it('App provider checks current platform', () => {\n    const appService = new CoreAppProvider();\n\n    expect(appService.isAndroid()).toBe(true);\n    expect(appService.isIOS()).toBe(false);\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["When you run it, it will fail because the testing platform is neither Android or iOS. You can make the test pass by providing a mock of the ",(0,s.jsx)(t.code,{children:"Platform"})," singleton that uses the platform of your choice:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"it('App provider checks current platform', () => {\n    const platforms = ['android']('cordova',);\n    const appService = new CoreAppProvider();\n\n    mockSingleton(Platform, {\n        is: platform => platforms.includes(platform),\n    });\n\n    expect(appService.isAndroid()).toBe(true);\n    expect(appService.isIOS()).toBe(false);\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Other than preparing the environment, this can also be useful to assert that other services have been used as expected. As you saw in this last example, the ",(0,s.jsx)(t.code,{children:"mockSingleton"})," method can be used to mock functions without needing to provide an explicit implementation. It uses the same api as the ",(0,s.jsx)(t.code,{children:"mock"})," helper we introduced in the previous section."]}),"\n",(0,s.jsx)(t.p,{children:"For example, in the following test you can see how we assert that copying text to the clipboard actually calls the native method and displays a confirmation message to the user:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"it('Copies data to clipboard', async () => {\n    // Arrange.\n    const domUtils = new CoreUtilsProvider(mock<NgZone>());\n\n    mockSingleton(Clipboard, [   mockSingleton(CoreDomUtils, ['showToast']('copy']);\n));\n\n    // Act.\n    await domUtils.copyToClipboard('Foo bar');\n\n    // Assert.\n    expect(Clipboard.copy).toHaveBeenCalledWith('Foo bar');\n    expect(CoreDomUtils.showToast).toHaveBeenCalledWith('core.copiedtoclipboard', true);\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:['Most services will be instantiated properly without mocks, but sometimes you may see the error "XX is not a function", or some service property that is undefined. This happens because if it\'s not possible to instantiate a service with an empty constructor, it will be provided as an empty object by default. If that happens, you just need to mock the methods and properties that are used in your test. Some basic services like ',(0,s.jsx)(t.code,{children:"Platform"})," and ",(0,s.jsx)(t.code,{children:"Network"})," already come with some basic mocks, but they are not exhaustive."]}),"\n",(0,s.jsx)(t.h2,{id:"testing-components",children:"Testing components"}),"\n",(0,s.jsxs)(t.p,{children:["Angular components have a strong graphical part, but that doesn't mean that you can't test their logic and markup rendering using unit tests with Jest. You can follow ",(0,s.jsx)(t.a,{href:"https://angular.io/guide/testing-components-scenarios",children:"Angular's best practices for testing components"}),", and we also provide a couple of helpers that make things easier."]}),"\n",(0,s.jsx)(t.p,{children:"Let's say you want to test the following component that render a list of user names:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"@Component({\n    selector: 'users-list',\n    template: `\n        <h1>Users List</h1>\n        <ul>\n            <li *ngFor=\"let user of users\">{{ user }}</li>\n        </ul>\n    `,\n})\nexport class UsersListComponent {\n\n    @Input() users: string[= [](]);\n\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If the component is simple enough that you don't need to provide any inputs, you can use the ",(0,s.jsx)(t.code,{children:"renderComponent"})," helper:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"it('Renders a header', async () => {\n    const fixture = await renderComponent(UsersListComponent);\n    const header = fixture.nativeElement.querySelector('h1');\n\n    expect(header).not.toBeNull();\n    expect(header.textContent).toBe('Users List');\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In the more common scenario that you need to provide inputs, you can use the ",(0,s.jsx)(t.code,{children:"renderTemplate"})," helper:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"it('Renders a list of users', async () => {\n    const fixture = await renderTemplate(\n        UsersListComponent,\n        `<users-list ['Amy'](users]=\"['John',)\"></users-list>`,\n    );\n    const list = fixture.nativeElement.querySelector('ul');\n\n    expect(list).not.toBeNull();\n    expect(list.children).toHaveLength(2);\n    expect(list.children[   expect(list.children[1](0].textContent).toEqual('John');\n).textContent).toEqual('Amy');\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["You can also achieve the same result the ",(0,s.jsx)(t.code,{children:"renderWrapperComponent"})," helper:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"it('Renders a list of users', async () => {\n    const fixture = await renderWrapperComponent(\n        UsersListComponent,\n        'users-list',\n        { users: ['Amy']('John',) },\n    );\n    const list = fixture.nativeElement.querySelector('ul');\n\n    expect(list).not.toBeNull();\n    expect(list.children).toHaveLength(2);\n    expect(list.children[   expect(list.children[1](0].textContent).toEqual('John');\n).textContent).toEqual('Amy');\n});\n"})}),"\n",(0,s.jsx)(t.h2,{id:"what-about-integration-tests",children:"What about integration tests?"}),"\n",(0,s.jsx)(t.p,{children:"Although this guide talks about unit tests, we don't follow the strict definition of a unit test (which is that a unit test should test a single unit in isolation)."}),"\n",(0,s.jsx)(t.p,{children:'We often write tests where multiple files (or "units") are involved, and sometimes that can be desirable because it is closer to how the app will behave in production. Technically, those would be considered integration tests, but you can use the same principles and techniques introduced in this document.'}),"\n",(0,s.jsxs)(t.p,{children:["If you want to write even more realistic tests, that are actually running the complete application and interacting with it like a real user would, you should check out the ",(0,s.jsx)(t.a,{href:"/moodledevdocs/general/app/development/testing/acceptance-testing",children:"Acceptance testing for the Moodle App"})," page."]})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);