"use strict";(self.webpackChunkdevdocs=self.webpackChunkdevdocs||[]).push([[12723],{54587:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(74848),s=n(28453),i=n(78924);const o={title:"Creating a reactive UI",tags:["JavaScript","Library","Frontend"]},r=void 0,l={id:"guides/javascript/reactive/index",title:"Creating a reactive UI",description:"Third-party plugin developers are free to use any framework they want to implement reactive interfaces like React, Angular or Vue. However, for now Moodle does not provide any of them and all core developments are framework independent.",source:"@site/versioned_docs/version-4.3/guides/javascript/reactive/index.md",sourceDirName:"guides/javascript/reactive",slug:"/guides/javascript/reactive/",permalink:"/moodledevdocs/docs/4.3/guides/javascript/reactive/",draft:!1,unlisted:!1,editUrl:"https://github.com/moodle/devdocs/edit/main/versioned_docs/version-4.3/guides/javascript/reactive/index.md",tags:[{label:"JavaScript",permalink:"/moodledevdocs/docs/4.3/tags/java-script"},{label:"Library",permalink:"/moodledevdocs/docs/4.3/tags/library"},{label:"Frontend",permalink:"/moodledevdocs/docs/4.3/tags/frontend"}],version:"4.3",lastUpdatedBy:"Andrew Nicols",lastUpdatedAt:1713332374e3,frontMatter:{title:"Creating a reactive UI",tags:["JavaScript","Library","Frontend"]},sidebar:"docs",previous:{title:"Modules",permalink:"/moodledevdocs/docs/4.3/guides/javascript/modules"},next:{title:"YUI",permalink:"/moodledevdocs/docs/4.3/guides/javascript/yui/"}},d={},c=[{value:"Reactive pattern highlights",id:"reactive-pattern-highlights",level:2},{value:"The basic classes",id:"the-basic-classes",level:2},{value:"Parts of a component",id:"parts-of-a-component",level:2},{value:"Extending the BaseComponent class",id:"extending-the-basecomponent-class",level:3},{value:"Instantiate a Component",id:"instantiate-a-component",level:3},{value:"Initialize a component from a mustache template",id:"initialize-a-component-from-a-mustache-template",level:3},{value:"The Component lifecycle hooks",id:"the-component-lifecycle-hooks",level:3},{value:"The <code>create(descriptor)</code> hook",id:"the-createdescriptor-hook",level:4},{value:"The <code>getWatchers(): array</code> hook",id:"the-getwatchers-array-hook",level:4},{value:"The <code>stateReady(state)</code> hook",id:"the-statereadystate-hook",level:4},{value:"The <code>destroy()</code> hook",id:"the-destroy-hook",level:4},{value:"Implementing state watchers",id:"implementing-state-watchers",level:3},{value:"State event names",id:"state-event-names",level:4},{value:"State event handlers",id:"state-event-handlers",level:4},{value:"Adding event listeners",id:"adding-event-listeners",level:3},{value:"Dispatching mutations from a component",id:"dispatching-mutations-from-a-component",level:3},{value:"Component custom events",id:"component-custom-events",level:3},{value:"BaseComponent helpers",id:"basecomponent-helpers",level:3},{value:"Add event listeners",id:"add-event-listeners",level:4},{value:"Get DOM elements",id:"get-dom-elements",level:4},{value:"Unregister and remove",id:"unregister-and-remove",level:4},{value:"Lock or unlock a component interface",id:"lock-or-unlock-a-component-interface",level:4},{value:"Render a subcomponent",id:"render-a-subcomponent",level:4},{value:"Start a new reactive application",id:"start-a-new-reactive-application",level:2},{value:"General workflow",id:"general-workflow",level:3},{value:"Create the Reactive Instance",id:"create-the-reactive-instance",level:3},{value:"Implement mutations library",id:"implement-mutations-library",level:3},{value:"Manually altering the state",id:"manually-altering-the-state",level:4},{value:"Using <code>stateManager.processUpdates</code> to alter the state",id:"using-statemanagerprocessupdates-to-alter-the-state",level:4},{value:"Private methods inside the mutations library",id:"private-methods-inside-the-mutations-library",level:4},{value:"Reserved <code>init</code> mutation method",id:"reserved-init-mutation-method",level:4},{value:"Set the initial state data",id:"set-the-initial-state-data",level:3},{value:"Initial state data limitations",id:"initial-state-data-limitations",level:4},{value:"Controlling the state from the backend",id:"controlling-the-state-from-the-backend",level:2},{value:"Format of a state update message",id:"format-of-a-state-update-message",level:3},{value:"Available update types",id:"available-update-types",level:3},{value:"Implementing custom update types",id:"implementing-custom-update-types",level:3},{value:"Adding default values to state attributes",id:"adding-default-values-to-state-attributes",level:3},{value:"Drag &amp; drop helper component",id:"drag--drop-helper-component",level:2},{value:"Implementing a draggable element",id:"implementing-a-draggable-element",level:3},{value:"Implementing a drop-zone component",id:"implementing-a-drop-zone-component",level:3}];function h(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:r,InvalidExample:d,Since:c,TabItem:h,Tabs:m,ValidExample:u}=t;return r||p("Details",!0),d||p("InvalidExample",!0),c||p("Since",!0),h||p("TabItem",!0),m||p("Tabs",!0),u||p("ValidExample",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.A,{frontMatter:o,metadata:l}),"\n",(0,a.jsx)(c,{versions:[4]}),"\n",(0,a.jsx)(t.p,{children:"Third-party plugin developers are free to use any framework they want to implement reactive interfaces like React, Angular or Vue. However, for now Moodle does not provide any of them and all core developments are framework independent."}),"\n",(0,a.jsx)(t.p,{children:"Nevertheless, in terms of reusability, maintainability and user experience the advantages of having a reactive UI are undeniable. For this reason Moodle has an adhoc reactive library that can be used to implement small reactive applications on any Moodle page."}),"\n",(0,a.jsx)(t.h2,{id:"reactive-pattern-highlights",children:"Reactive pattern highlights"}),"\n",(0,a.jsx)(t.p,{children:"To understand the advantages (and disadvantages) of a reactive User Interface (UI) there are a few major points you must understand about reactivity:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["All the reactive UI logic is divided by ",(0,a.jsx)(t.strong,{children:"components"})," and all components are implemented in the same way (extending a ",(0,a.jsx)(t.code,{children:"BaseComponent"})," class) so they can be as reusable and maintainable as possible."]}),"\n",(0,a.jsxs)(t.li,{children:["The UI must be a representation of a data structure called ",(0,a.jsx)(t.strong,{children:"state"})," and this representation must be updated every time that state changes. A state change is called state ",(0,a.jsx)(t.strong,{children:"mutation"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"User interaction never changes the UI"}),". Any interaction can mutate the state data but never alter the HTML structure. Only state mutations can alert components to do a UI change."]}),"\n",(0,a.jsx)(t.li,{children:"The same happens with web services. Except for loading new UI components/templates, all web services must be designed to mutate the current state data, not the interface."}),"\n"]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View extra explanation on how the reactive pattern works"}),(0,a.jsxs)("div",{children:[(0,a.jsx)(t.p,{children:"One of the principles of the reactive pattern is that the HTML must always represent the current state data."}),(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Super Mario video game example"})}),(0,a.jsxs)(t.p,{children:["Imagine there are at least two ",(0,a.jsx)(t.strong,{children:"components"})," on the same screen:"]}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Mario"}),": the main character"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Counter"}),": the lives counter"]}),"\n"]}),(0,a.jsxs)(t.p,{children:["When the Mario ",(0,a.jsx)(t.strong,{children:"component"}),' collides with an enemy triggers the "enemyHit" ',(0,a.jsx)(t.strong,{children:"state mutation"}),' but it won\'t handle the number of life itself. The responsibility for deciding if Mario loses a life or not is in the "enemyHit" mutation which, depending on whether Mario has eaten a mushroom or not, will decide to alter the ',(0,a.jsx)(t.strong,{children:"state data"})," in a particular way (losing a life or making it small)."]}),(0,a.jsxs)(t.p,{children:["The other ",(0,a.jsx)(t.strong,{children:"component"}),", the lives Counter, just defines a ",(0,a.jsx)(t.strong,{children:"state watcher"}),' method to listen to the "lives" integer in the state. Every time any mutation alters that value it will increase the displayed number because it can trust the state data. This is called the ',(0,a.jsx)(t.strong,{children:"Unique Source of Truth"}),'. No matter if the lives change because of a "enemyHit" or an "extraLifeHit" mutation, the Counter will only trust the current state "lives" value, not the reason of the change.']}),(0,a.jsx)(t.p,{children:"Imagine now that we don't use a reactive pattern and watcher methods. Whenever the lives integer changes we need to refresh the life counter HTML manually in every involved event (the enemy hit, the extra life hit, falling into the void...). If this happens:"}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"If at some point we want to add a new event related to lives number (for example losing a life when level time limit is reached) we need to remember including the lives Counter refresh on that event too."}),"\n",(0,a.jsx)(t.li,{children:"The situation is even worse if we add a new component related to the lives number (for example a Luigi that helps the player if it is in the last life). In that case the Luigi's refresh must be added to all events one by one."}),"\n",(0,a.jsx)(t.li,{children:"Because the UI changes are not really driven by state mutations events but for hardcoded calls, any UI update exception will block the rest of the updates. This means that the state data will no longer be represented by the UI unless we add try-catch blocks all over the code."}),"\n"]}),(0,a.jsxs)(t.p,{children:["Even encapsulating the logic in a few methods the complexity will increase exponentially with every new UI ",(0,a.jsx)(t.strong,{children:"component"})," and ",(0,a.jsx)(t.strong,{children:"mutation"}),"."]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"the-basic-classes",children:"The basic classes"}),"\n",(0,a.jsx)(t.p,{children:"Reactive interfaces can be used in many ways, but all of them are supported by 4 main elements."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Basic reactive classes diagram",src:n(85647).A+"",width:"1024",height:"430"})}),"\n",(0,a.jsxs)(m,{children:[(0,a.jsx)(h,{value:"components",label:"Components",default:!0,children:(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"All reactive UI is divided into components. Each component takes care of a specific DOM element (and its children)."}),"\n",(0,a.jsx)(t.p,{children:"Its basic responsibilities are:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Once created it must register itself into a reactive instance (a kind of a controller)."}),"\n",(0,a.jsxs)(t.li,{children:["Watch a data structure called ",(0,a.jsx)(t.strong,{children:"state"}),". Every time that structure changes the component must guarantee its main DOM element represents the updated state."]}),"\n",(0,a.jsxs)(t.li,{children:["Captures user interactions inside its main DOM element. If the user interaction requires some changes in the state, the component cannot change the state but can ask for its reactive instance. That is called ",(0,a.jsx)(t.strong,{children:"dispatch a mutation"}),"."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Apart, a component can also:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Delegate some of the logic to subcomponents."}),"\n",(0,a.jsx)(t.li,{children:"Destroy themselves when they are not needed"}),"\n",(0,a.jsx)(t.li,{children:"Lock the element if the user cannot interact with temporally"}),"\n"]}),"\n"]})}),(0,a.jsx)(h,{value:"reactive",label:"Reactive instance",children:(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"The reactive instance is a kind of controller. It registers every other piece in the reactive app and centralizes almost all interactions between them. All components from the same reactive application share the same reactive instance."}),"\n",(0,a.jsx)(t.p,{children:"Its basic responsibilities are:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Keep a list of all registered components."}),"\n",(0,a.jsx)(t.li,{children:"Trigger component watchers when specific parts of the state changes"}),"\n",(0,a.jsx)(t.li,{children:"Give components read-only access to the state data"}),"\n",(0,a.jsx)(t.li,{children:"Dispatch mutations on the state. To do so it uses a Mutation object (a library with all available mutations) and a State Manager (the object responsible for storing the state and allow writing)."}),"\n"]}),"\n"]})}),(0,a.jsx)(h,{value:"statemanager",label:"State Manager",children:(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"Components can access the state data but they cannot interact with the state manager. Only the Reactive instance and the mutations can interact with the state manager."}),"\n",(0,a.jsx)(t.p,{children:"Its basic responsibilities are:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Protect the state data from being modified by the components"}),"\n",(0,a.jsx)(t.li,{children:"Allow state modifications when a mutation requires it"}),"\n",(0,a.jsx)(t.li,{children:"Trigger JS events when the state data changes (those events are captured by the Reactive instance)."}),"\n"]}),"\n"]})}),(0,a.jsx)(h,{value:"mutations",label:"Mutation Library",children:(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"The mutations object is a library containing all the available state modifications the application has. Components cannot access the mutation library directly but they can dispatch a mutation via their Reactive instance (using the dispatch method)."}),"\n",(0,a.jsx)(t.p,{children:"Its basic responsibilities are:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Alter the state data when a component asks for it to the Reactive instance. To do so it needs to set the state writable using the State Manager."}),"\n",(0,a.jsx)(t.li,{children:"Keep the state data consistent."}),"\n",(0,a.jsx)(t.li,{children:"Centralizes and synchronizes all state changes with the backend. This means that, in general, all backend operations must be called inside mutations. Components can render mustache files, get strings, load HTML fragments, or other read-only web services, but they should never call for write web services themselves."}),"\n"]}),"\n"]})})]}),"\n",(0,a.jsx)(t.h2,{id:"parts-of-a-component",children:"Parts of a component"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:"React Components"})," represent most of the work on building a reactive UI. In general, the ",(0,a.jsx)(t.em,{children:"Reactive Instance"})," and the ",(0,a.jsx)(t.em,{children:"State Manager"})," can be used as they are provided, and Mutations contain only the interactions with the server and the state. The React Components are where all the UI logic is implemented."]}),"\n",(0,a.jsx)(t.p,{children:"Components can do many things but, in general, they are not hard to implement because they are always structured in the same way and the BaseComponent class does all the hard part for us. There are only a few scenarios where a reactive component can be more complicated than a traditional JS undefined pattern code and, even in those cases, the maintainability is much better."}),"\n",(0,a.jsx)(t.p,{children:"Let's take a look at the component anatomy."}),"\n",(0,a.jsx)(t.h3,{id:"extending-the-basecomponent-class",children:"Extending the BaseComponent class"}),"\n",(0,a.jsx)(t.p,{children:"All reactive UIs are object-oriented and all components extend the BaseComponent class. This means that the default component structure is very simple. For example:"}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsx)("div",{children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="path/to/plugin/amd/src/yourcomponent.js"',children:"import {BaseComponent} from 'core/reactive';\n\nexport default class extends BaseComponent {\n(...)\n}\n"})})})]}),"\n",(0,a.jsx)(t.h3,{id:"instantiate-a-component",children:"Instantiate a Component"}),"\n",(0,a.jsx)(t.p,{children:"Any component belongs to one DOM element and is registered in a Reactive Instance. This means that to create a new instance we need to provide at least those two elements. For example:"}),"\n",(0,a.jsxs)(m,{children:[(0,a.jsx)(h,{value:"init-js-module",label:"AMD module",default:!0,children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="path/to/plugin/amd/src/main.js"',children:"import {reactiveInstance} from 'YOUR_PLUGIN/reactive';\nimport YourComponent from 'YOUR_PLUGIN/yourcomponent;\n\n(...)\n\nexport const init = (domElementId) => {\n    return new YourComponent({\n        element: document.getElementById(domElementId),\n        reactive: reactiveInstance,\n        (... other data your component needs ...)\n    });\n}\n"})})}),(0,a.jsx)(h,{value:"init-php-module",label:"PHP code",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-php",metastring:'title="path/to/plugin/amd/src/index.php"',children:"(...)\n\n$PAGE->requires->js_call_amd('YOUR_PLUGIN/main', 'init', [$domelementid]);\n"})})})]}),"\n",(0,a.jsx)(t.p,{children:"In case no Reactive Instance is passed, the BaseComponent will try to inherit the instance from a parent DOM element. This way subcomponents can omit that param."}),"\n",(0,a.jsx)(t.h3,{id:"initialize-a-component-from-a-mustache-template",children:"Initialize a component from a mustache template"}),"\n",(0,a.jsxs)(t.p,{children:['Components are easy to embed in mustache files. To do so your class must have a static "init" method that could be called inside the ',(0,a.jsx)(t.code,{children:"{{#js}}"}),"."]}),"\n",(0,a.jsxs)(m,{children:[(0,a.jsx)(h,{value:"component-view",label:"Component class",default:!0,children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="path/to/plugin/amd/src/childcomponent.js"',children:"import {BaseComponent} from 'core/reactive';\nimport {reactiveInstance} from 'YOUR_PLUGIN/reactive';\n\nexport default class extends BaseComponent {\n    static init(target, selectors) {\n        return new this({\n            element: document.getElementById(target),\n            reactive: reactiveInstance,\n            selectors,\n        });\n    }\n    // (...)\n}\n"})})}),(0,a.jsxs)(h,{value:"mustache-view",label:"Mustache file",children:[(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-handlebars",metastring:'title="path/to/plugin/templates/yourthing/childcomponent.mustache"',children:"<div id=\"{{uniqid}}-your-plugin-{{id}}\"> (...) </div>\n{{#js}}\nrequire(['YOUR_PLUGIN/local/yourthing/childcomponent'], function(component) {\n    component.init('{{uniqid}}-your-plugin-{{id}}');\n});\n{{/js}}\n"})}),(0,a.jsxs)(t.admonition,{title:"Generating unique id attributes",type:"tip",children:[(0,a.jsxs)(t.p,{children:["You can use the ",(0,a.jsx)(t.code,{children:"{{uniqid}}"})," Mustache helper within your code to help you generate a unique id for your HTML attributes and target them in your React component."]}),(0,a.jsxs)(t.p,{children:["Please note that the ",(0,a.jsx)(t.code,{children:"{{uniqid}}"})," helper generates a single value each time it is rendered, and you will need to combine it with other data to create a truly unique value. In this example the name of the plugin, and a static element ",(0,a.jsx)(t.code,{children:"id"})," is used to generate a unique value."]})]})]})]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsxs)(t.p,{children:["The init method has an id as a first param to find the main DOM Element, but it also has a second one called ",(0,a.jsx)(t.code,{children:"selectors"}),". This second param is an optional (but recommended) param any component can use. We will see how to use the selectors later but they are CSS selectors to find inner DOM elements in the main element. Bypassing as an init-param, any mustache can customize the default CSS selectors, which means the component is more reusable."]})}),"\n",(0,a.jsx)(t.h3,{id:"the-component-lifecycle-hooks",children:"The Component lifecycle hooks"}),"\n",(0,a.jsx)(t.p,{children:"All components are registered in a Reactive Instance and, when this is done, the Component can start watching the state and ask for state mutations. However, during its life, a Component can operate differently if necessary."}),"\n",(0,a.jsx)(t.p,{children:"To understand how a component works you need to understand the component lifecycle and its hook methods:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Component lifecycle hooks",src:n(93793).A+"",width:"1024",height:"618"})}),"\n",(0,a.jsxs)(m,{children:[(0,a.jsxs)(h,{value:"create",label:"create",default:!0,children:[(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Called"}),": Before the component is registered to the Reactive Instance."]}),(0,a.jsx)(t.p,{children:"This method is used to define the main component attributes. The Component cannot interact with the Reactive Instance yet as instantiation has not yet completed."}),(0,a.jsxs)(t.h4,{id:"the-createdescriptor-hook",children:["The ",(0,a.jsx)(t.code,{children:"create(descriptor)"})," hook"]}),(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"BaseComponent"})," construct method will register the component in the Reactive Instance after some validations. It is quite common for components to have private attributes needed for the UI logic. Components can set their own attributes in the ",(0,a.jsx)(t.code,{children:"create"})," hook method."]}),(0,a.jsxs)(t.p,{children:["The method will receive an object called ",(0,a.jsx)(t.code,{children:"descriptor"})," which contains the data structure passed to the constructor. This method can define its own CSS selectors, classes, or any other constant needed, so defining it as the first method in the class is a good practice."]}),(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsxs)("div",{children:[(0,a.jsx)(t.p,{children:"The typical create method looks like:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"create(descriptor) {\n    // An optional component name for debugging.\n    this.name = 'courseindex_cm';\n\n    // Those are the component CSS selectors, in uppercase\n    // are used as constants.\n    this.selectors = {\n        EXAMPLESELECTOR: `[data-for='example']`,\n    };\n\n    // If the component manage CSS classes, the constants should\n    // be defined the same way as the selectors.\n    this.classes = {\n        HIDDEN: 'dimmed',\n    };\n\n    // The main HTML element is stored in \"this.element\" as well\n    // in \"descriptor.element\".\n    this.id = this.element.dataset.id;\n\n    (... any other data extracted from the \"descriptor\"...)\n}\n"})})]})]}),(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["When create is called the component has an ",(0,a.jsx)(t.code,{children:"element"})," attribute because it should read data from the main element but it does not have a ",(0,a.jsx)(t.code,{children:"this.reactive"})," attribute because the component can be registered before having a fully functional Reactive Instance. Any initialization that requires a reactive instance or a state should be done in later hooks like stateReady or getWatchers."]})})]}),(0,a.jsxs)(h,{value:"getWatchers",label:"getWatchers",children:[(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Called"}),": when the Reactive Instance is registering the component."]}),(0,a.jsx)(t.p,{children:"At the moment the Reactive Instance is registering the component and asking it what parts of the state it is watching. This method returns a list of state changes the component is watching and the methods that will handle those changes, something like an event listener for state changes."}),(0,a.jsxs)(t.h4,{id:"the-getwatchers-array-hook",children:["The ",(0,a.jsx)(t.code,{children:"getWatchers(): array"})," hook"]}),(0,a.jsx)(t.p,{children:"At this moment the component can specify which state changes are watching and what methods will use to listen to those changes."}),(0,a.jsx)(t.p,{children:"The method should return an array of objects containing, with each object containing:"}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["watch: the state changes to watch. For example ",(0,a.jsx)(t.code,{children:"user.username:update"})]}),"\n",(0,a.jsxs)(t.li,{children:["handler: the class method to handle the state change event. For example ",(0,a.jsx)(t.code,{children:"this._refreshUsername"}),"."]}),"\n"]}),(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View examples"}),(0,a.jsxs)("div",{children:[(0,a.jsx)(t.p,{children:"This is a real example of getWatchers from a course index module:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"getWatchers() {\n    return [\n        {watch: `cm:created`, handler: this._createCm},\n        {watch: `cm:deleted`, handler: this._deleteCm},\n        {watch: `section:created`, handler: this._createSection},\n        {watch: `section:deleted`, handler: this._deleteSection},\n    ];\n}\n"})}),(0,a.jsx)(t.p,{children:"In case the component only watches changes in a specific element of a state collection, the function could be something like."}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"getWatchers() {\n    // The this.element is the component's main DOM element passed as a param in the construct method.\n    const id = this.element.dataset.id;\n    return [\n        {watch: `cm[${id}]:created`, handler: this._createCm},\n        {watch: `cm[${id}]:deleted`, handler: this._deleteCm},\n        {watch: `section[${id}]:created`, handler: this._createSection},\n        {watch: `section[${id}]:deleted`, handler: this._deleteSection},\n    ];\n}\n"})})]})]}),(0,a.jsxs)(t.admonition,{type:"note",children:[(0,a.jsxs)(t.p,{children:["No need to manually ",(0,a.jsx)(t.code,{children:"bind"})," or use the ",(0,a.jsx)(t.code,{children:"call"})," function!"]}),(0,a.jsxs)(t.p,{children:["All the components code is designed to maintain the ",(0,a.jsx)(t.code,{children:"this"})," value constant. This means that handlers don't need any kind of bind because the Reactive Instance will do it before registering the component. The same happens with event listeners."]})]}),(0,a.jsxs)(t.p,{children:["See the ",(0,a.jsx)(t.a,{href:"#implementing-state-watchers",children:"Implement state watchers"})," section for more information."]})]}),(0,a.jsxs)(h,{value:"stateReady",label:"stateReady",children:[(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Called"}),": when the state data is initially loaded."]}),(0,a.jsx)(t.p,{children:"When the reactive instance has the initial state loaded. Is important to note that this method will be called even if the component is registered after the initial state is loaded. For all purposes, this method is the equivalent of a page ready for components."}),(0,a.jsxs)(t.h4,{id:"the-statereadystate-hook",children:["The ",(0,a.jsx)(t.code,{children:"stateReady(state)"})," hook"]}),(0,a.jsx)(t.p,{children:"This is one of the most important hooks in the Component lifecycle. At this moment the component will get its state and it can ensure that the Reactive Instance is ready and its watchers are working."}),(0,a.jsx)(t.p,{children:"Even if the component is registered once the initial state is loaded, the Reactive Instance will trigger that method when the Component is fully registered and the page is ready. For all purposes, this method is the equivalent of a page-ready event for components."}),(0,a.jsx)(t.p,{children:"The typical actions for a stateReady are:\nAdd event listeners to capture user interactions.\nRefresh parts of the main element using the state data.\nDelegate logic to subcomponents."}),(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.a,{href:"#basecomponent-helpers",children:"BaseComponent helpers"})," section will discuss this in more detail."]})]}),(0,a.jsxs)(h,{value:"destroy",label:"destroy",children:[(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Called"}),": before the component is unregistered."]}),(0,a.jsx)(t.p,{children:"After this method is called the Component will no longer watch the state or capture the user interactions, even if the component's main DOM element is still present on the page."}),(0,a.jsxs)(t.h4,{id:"the-destroy-hook",children:["The ",(0,a.jsx)(t.code,{children:"destroy()"})," hook"]}),(0,a.jsx)(t.p,{children:"This hook will be executed when the component is unregistered from the Reactive Instance or removed from the page (which will also unregister it). This method is used to clean some dependencies. In general, this method is used to propagate the unregister to the subcomponents when some logic is delegated."}),(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsxs)("div",{children:[(0,a.jsxs)(t.p,{children:["In the example the component has some drag&drop logic that uses the reactive ",(0,a.jsx)(t.code,{children:"DragDrop"})," module, the drag-drop subcomponent should be removed and initialized in the ",(0,a.jsx)(t.code,{children:"stateReady"})," method and unregistered in the ",(0,a.jsx)(t.code,{children:"destroy"})," one."]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {BaseComponent, DragDrop} from 'core/reactive';\n\n(...)\n\nstateReady(state) {\n    (...)\n    this.dragdrop = new DragDrop(this);\n}\n\ndestroy() {\n    this.dragdrop.unregister();\n}\n"})})]})]})]})]}),"\n",(0,a.jsx)(t.h3,{id:"implementing-state-watchers",children:"Implementing state watchers"}),"\n",(0,a.jsxs)(t.p,{children:["Reacting to state data changes is the main way in which components can refresh the interface. The major reactive framework uses complex black-boxing to encapsulate most of the watchers and templates logic. This is why the general feeling is that they magically work. In our case, we use mustache as the main template library, meaning no dynamic refresh is available. Instead, ",(0,a.jsx)(t.code,{children:"core/reactive"})," components watch low-level state events, which are faster, but less magical."]}),"\n",(0,a.jsx)(t.p,{children:"To facilitate the examples, all of them will suppose the following state data:"}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example state data"}),(0,a.jsx)("div",{children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'{\n    "activity": {"name": "Something", "id": 42},\n    "students": [\n       {"id": 1, "username": "Jane Doe", "attempts": 3},\n       {"id": 2, "username": "John Doe", "attempts": 1},\n    ],\n}\n'})})})]}),"\n",(0,a.jsx)(t.h4,{id:"state-event-names",children:"State event names"}),"\n",(0,a.jsx)(t.p,{children:"Components can subscribe to as many state events as needed. All events are identified by a string with the following formats:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Element:Action"}),' (example: "students',":updated",'")']}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Element.Attribute:Action"}),' (example: "students.attempts',":deleted",'")']}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"SetName[ID]:Action"}),' (example: "students[3]',":created",'")']}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"SetName[ID].attribute:Action"}),' (example: "students[3].attempts',":updated",'")']}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The same state change will dispatch more than one event, from more generic to more specific."}),"\n",(0,a.jsxs)(t.p,{children:["In case a mutation alters more than one state value all changes will be stacked in the same transaction. However, they will be sorted this order: ",(0,a.jsx)(t.strong,{children:"creations, updates and finally deletes"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"This order is important because creations may require rendering new components while update and delete require an already created element."}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["The best way to identify which events a mutation will produce is using the state events log in the ",(0,a.jsx)(t.strong,{children:"reactive debug tools"}),". To show the reactive debug tools the Debug messages should be set to DEVELOPER. Once done the reactive debug options will appear at any footer."]})}),"\n",(0,a.jsxs)(m,{children:[(0,a.jsx)(h,{value:"watcher_example1",label:"Example 1",default:!0,children:(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"A mutation that does:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"state.activity.name = \u2018New name\u2019;\n"})}),"\n",(0,a.jsx)(t.p,{children:"Will trigger:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"transaction:start\nactivity.name:updated\nactivity:updated\nstate:updated\ntransaction:end\n"})}),"\n"]})}),(0,a.jsx)(h,{value:"watcher_example23",label:"Example 2",children:(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"A mutation that does:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"students[2].attempts = 2;\n"})}),"\n",(0,a.jsx)(t.p,{children:"Will trigger:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"transaction:start\nstudents.attempts:updated\nstudents[2].attempts:updated\nstudents[2]:updated\nstudents:updated\nstate:updated\ntransaction:end\n"})}),"\n"]})}),(0,a.jsx)(h,{value:"watcher_example3",label:"Example 3",children:(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"A mutation that does:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"students[2].attempts = 2;\ndelete students[1];\n"})}),"\n",(0,a.jsx)(t.p,{children:"Will trigger:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"transaction:start\nstudents.attempts:updated\nstudents[2].attempts:updated\nstudents[2]:updated\nstudents:updated\nstate:updated\nstudents[1]:deleted\nstudents:deleted\nstate:updated\ntransaction:end\n"})}),"\n"]})})]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"state:updated"})," change is triggered by every state change. That is because each state change affects a specific state object that will be passed to the handler."]})}),"\n",(0,a.jsx)(t.h4,{id:"state-event-handlers",children:"State event handlers"}),"\n",(0,a.jsxs)(t.p,{children:["When the event is detected the Reactive Instance will collect all the event details in a data structure and will send it to the handlers. Except for the ",(0,a.jsx)(t.code,{children:"transaction:start"})," and ",(0,a.jsx)(t.code,{children:"transaction:end"})," that data structure will contain always the following objects:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Action"}),": the action name"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"State"}),": the full state data"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Element"}),": the affected state element"]}),"\n"]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View update user attemps example"}),(0,a.jsx)("div",{children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {BaseComponent} from 'core/reactive';\nimport {reactiveInstance} from 'YOUR_PLUGIN/reactive';\n\nexport default class extends BaseComponent {\n\n    create() {\n        this.selectors = {\n            ATTEMPTS: `[data-for=\"attempts\"]`,\n        };\n    }\n\n    getWatchers() {\n        return [\n            {watch: `students.attempts:updated`, handler: this._refreshStudent},\n        ];\n    }\n\n    // In this case we only want the affected element.\n    _refreshStudent({element}) {\n        const element = this.getElement(this.selectors.ATTEMPTS, element.id);\n        element.innerHTML = element.attempts;\n    }\n\n}\n"})})})]}),"\n",(0,a.jsx)(t.h3,{id:"adding-event-listeners",children:"Adding event listeners"}),"\n",(0,a.jsx)(t.p,{children:"Most components will listen to events on their inner elements like buttons, inputs, draggable\u2026 To prevent each component from reinventing the wheel, there are some good practices every component should follow."}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:'All element selectors should be declared in the "create" hook as part of the "this.selectors" attribute. This way selectors can be overridden on the mustache file if necessary.'}),"\n",(0,a.jsx)(t.li,{children:'Unless there\'s a good reason for it, all event listeners should be added in the "stateReady" hook. That is the first moment where the code can guarantee there\'s valid state data, the "this.reactive" is correct and the "this.element" is ready.'}),"\n",(0,a.jsxs)(t.li,{children:['To add event listeners components should use the "this.addEventListener" method instead of element one. This way the Reactive Instance can remove all listeners of a component when it is unregistered (see the ',(0,a.jsx)(t.a,{href:"#basecomponent-helpers",children:"BaseComponent helpers"})," section for more information)."]}),"\n"]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View adding a listener to a button example"}),(0,a.jsx)("div",{children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {BaseComponent} from 'core/reactive';\nimport {reactiveInstance} from 'YOUR_PLUGIN/reactive';\n\nexport default class extends BaseComponent {\n    create() {\n        // Declare selector in the create hook.\n        this.selectors = {\n            SUBMITBTN: `[data-for=\"submitattempt\"]`,\n        };\n    }\n\n    stateReady() {\n        // Add a click listener to the submit button.\n        this.addEventListener(\n            this.getElement(this.selectors.SUBMITBTN),\n            'click',\n            this._submitAttempt\n        );\n\n    }\n\n    _submitAttempt(event) {\n        Const userid = event.target.dataset.id;\n        (...)\n        // In the next section this method will dispatch a state mutation.\n    }\n}\n"})})})]}),"\n",(0,a.jsx)(t.h3,{id:"dispatching-mutations-from-a-component",children:"Dispatching mutations from a component"}),"\n",(0,a.jsx)(t.p,{children:"Components cannot alter the state themselves (it will raise an exception if they try). Instead, they can ask the Reactive Instance to execute a state mutation. For components mutations are just a bunch of async commands the Reactive Instance can execute to alter the state. The section Start a new reactive application will cover how to implement state mutations but for now considering them a BlackBox is enough."}),"\n",(0,a.jsxs)(t.p,{children:["All reactive instances have a ",(0,a.jsx)(t.code,{children:"dispatch"})," method to trigger a mutation. The component can dispatch any mutation doing:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"this.reactive.dispatch(MUTATIONNAME, [param1, param2...]);\n"})}),"\n",(0,a.jsx)(t.p,{children:"The only mandatory parameter to dispatch a mutation is the mutation name. The mutation name is the method name inside the mutation library. Let's see an example."}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsxs)("div",{children:[(0,a.jsxs)(t.p,{children:["Calling a mutation called ",(0,a.jsx)(t.code,{children:"submitAttemps"})," from the previous example. The ",(0,a.jsx)(t.code,{children:"submitAttempts"})," get the user as a param."]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {BaseComponent} from 'core/reactive';\nimport {reactiveInstance} from 'YOUR_PLUGIN/reactive';\n\nexport default class extends BaseComponent {\n    create() {\n        this.selectors = {\n            ATTEMPTS: `[data-for=\"attempts\"]`,\n            SUBMITBTN: `[data-for=\"submitattempt\"]`,\n        };\n    }\n\n    // Add a click listener to the submit button.\n    stateReady() {\n        this.addEventListener(\n            this.getElement(this.selectors.SUBMITBTN),\n            'click',\n            this._submitAttempt\n        );\n\n    }\n\n    getWatchers() {\n        return [\n            {watch: `students.attempts:updated`, handler: this._refreshStudent},\n        ];\n    }\n\n    _refreshStudent({element}) {\n        const element = this.getElement(this.selectors.ATTEMPTS, element.id);\n        element.innerHTML = element.attempts;\n    }\n\n    _submitAttempt(event) {\n        Const userid = event.target.dataset.id;\n        this.reactive.dispatch(\u2018submitAttempt\u2019, userid);\n    }\n}\n"})})]})]}),"\n",(0,a.jsxs)(t.p,{children:["Because the component already reacts to the state change ",(0,a.jsx)(t.code,{children:"students.attempts:updated"})," the button just dispatches the mutation without changing the interface. Who dispatches the mutation does not matter because all watchers will be alerted when this happens. Even later, when more buttons dispatch the same mutation everything will work perfectly if components are well designed. That is where the reactivity pattern shines the most."]}),"\n",(0,a.jsx)(t.h3,{id:"component-custom-events",children:"Component custom events"}),"\n",(0,a.jsx)(t.p,{children:"Because all components are built more or less the same way, making them reusable is easy. With the proper selectors, any component can use another component logic for part of its interface."}),"\n",(0,a.jsx)(t.p,{children:"Some components can be designed to work as a subcomponent of another component. There are several ways in which a child component can communicate with the parent one, but the most standard one is by using custom events."}),"\n",(0,a.jsx)(t.p,{children:"If we want to implement reusable components with custom events it is important to follow the following best practices:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:'If a component uses custom events, the event names should have a static method "getEvents" to get them (there\'s an example below). Also, that method should be the first method of the class, just before the "create" hook. This way all the important definition methods would be easier to discover. The method should be static because the event\'s name should be always accessible.'}),"\n",(0,a.jsx)(t.li,{children:"In case the custom event is using one of the custom events from the plugin's events.js, the static getEvents method should also return it."}),"\n",(0,a.jsx)(t.li,{children:'Unless the component uses an alternative method to dispatch events (for example one from the specific plugin events.js), it is recommended to use the convenience method "this.dispatchEvent" to trigger a custom event.'}),"\n",(0,a.jsx)(t.li,{children:'Inside the component, custom events can be accessed via "this.events" attribute.'}),"\n"]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsxs)("div",{children:[(0,a.jsx)(t.p,{children:"A component dispatching a custom event."}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {BaseComponent} from 'core/reactive';\nimport {debounce} from 'core/utils';\n\nexport default class extends BaseComponent {\n    static getEvents() {\n        return {\n            renamed: 'plugin_renamevalue:changed',\n        };\n    }\n\n    create() {\n        this.selectors = {\n            INPUT: `input`,\n        };\n    }\n\n    stateReady() {\n        const input = this.getElement(this.selectors.INPUT);\n        const debounceddispatch = debounce(() => {\n            this.dispatchEvent(\n                this.events.renamed,\n                {component: this},\n            );\n        }, 250);\n        this.addEventListener(input, 'keyup', debounceddispatch);\n    }\n}\n"})})]})]}),"\n",(0,a.jsx)(t.h3,{id:"basecomponent-helpers",children:"BaseComponent helpers"}),"\n",(0,a.jsx)(t.p,{children:"The BaseComponent class offers some helpers to standardize the components' code and make them more maintainable."}),"\n",(0,a.jsx)(t.h4,{id:"add-event-listeners",children:"Add event listeners"}),"\n",(0,a.jsx)(t.p,{children:"Reactive components are that they can be registered and unregistered (or even removed) at any moment. This implies that the Reactive Instance should have a way of unregister a component, invalidating all the event listeners and the state watchers."}),"\n",(0,a.jsx)(t.p,{children:'As explained in the getWatchers hook, watchers have an implicit "bind(this)" to ensure all components have a "this" constant in all the methods. The same happens to event listeners. The BaseComponent class has specific methods to add and remove event listeners easily:'}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"this.addEventListener(ELEMENT, EVENTNAME, this.METHODNAME)"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"this.removeEventListener(ELEMENT, EVENTNAME, this.METHODNAME)"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"this.removeAllEventListeners()"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"this.dispatchEvent(EVENTNAME, DETAIL)"})}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Using those methods your code will be much clear because:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:'Having the "this" value is constant, you don\'t need to worry about binding all the events and watchers all the time.'}),"\n",(0,a.jsx)(t.li,{children:"The method code is more reusable as it could be used as an internal function, as an event listener, or as a watcher."}),"\n",(0,a.jsx)(t.li,{children:'The BaseComponent registers all listeners in a way that you can use this.removeEventListener or this.removeAllEventListeners to disable listeners just by passing the regular "this.METHODNAME".'}),"\n"]}),"\n",(0,a.jsx)(t.h4,{id:"get-dom-elements",children:"Get DOM elements"}),"\n",(0,a.jsx)(t.p,{children:"Each component takes care of the main DOM element and its children. This means all the DOM queries a component uses should be inside the main DOM element but not in all the document."}),"\n",(0,a.jsx)(t.p,{children:"There are two ways of accessing the components main DOM element:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"this.element"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"this.getElement(): HTMLElement"})}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"When you need to find an inner element inside the main element you should use:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"this.getElement(QUERY [, DATAID]): HTMLElement|undefined"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"this.getElements(QUERY [, DATAID]): NodeList|undefined"})}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"As you may guess, getElement returns a single element while getElements return a node list. Let's take a look at the method params:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"QUERY"}),": this is a CSS query selector. In general, should be one of the constants of ",(0,a.jsx)(t.code,{children:"this.selectors"})," defined in the create method."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"DATAID"}),": this is an optional param. If this param is passed the method will automatically add ",(0,a.jsx)(t.code,{children:"[data-id='${dataid}']"})," to the query. This is a convenience param to force all components to follow the best practices like using data attributes for the logic instead of classes or other CSS reserved values."]}),"\n"]}),"\n",(0,a.jsx)(t.h4,{id:"unregister-and-remove",children:"Unregister and remove"}),"\n",(0,a.jsx)(t.p,{children:"There are two ways in which a component can be invalidated:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"this.unregister()"}),": will unregister the component, disabling all watchers and event listeners. However, the component's main DOM element won't be altered in any way."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"this.remove()"}),": will unregister the component but also remove the component's main DOM element."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Both methods will execute the ",(0,a.jsx)(t.code,{children:"destroy"})," hook."]}),"\n",(0,a.jsx)(t.h4,{id:"lock-or-unlock-a-component-interface",children:"Lock or unlock a component interface"}),"\n",(0,a.jsxs)(t.p,{children:["Sometimes a component may be waiting for some mutations to be executed. Usually, we don't want user interactions while this is happening. To prevent this from happening the ",(0,a.jsx)(t.code,{children:"BaseCompoment"})," has a boolean attribute ",(0,a.jsx)(t.code,{children:"locked"})," to lock/unlock the component's main DOM element. A locked component will stop listening to user interactions like clicks, selections or drag&drop."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"this.locked = true; // Locks the component\nthis.locked = false; // Unlocks the component.\n"})}),"\n",(0,a.jsx)(t.p,{children:"However, it is also possible to only lock or unlock internal elements. To do so BaseComponent has two methods:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"setElementLocked(ELEMENT, bool)"}),": the first param is the HTML element to lock/unlock"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"getElementLocked(ELEMENT)"}),": returns the current locked value of the element."]}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"Locking or unlocking an element won't add any style to the element. The component should add any CSS classes necessary to make this locking visual."})}),"\n",(0,a.jsx)(t.h4,{id:"render-a-subcomponent",children:"Render a subcomponent"}),"\n",(0,a.jsx)(t.p,{children:"Sometimes using events to communicate components is not enough. For those cases, the BaseComponent class has a method called renderComponent."}),"\n",(0,a.jsx)(t.p,{children:"Parameters:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"target"}),": The HTML element to replace with the document."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"template"}),": the mustache template path"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"data"}),": the mustache data"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Returns:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"A Promise for a component instance."}),"\n"]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsx)("div",{children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"async stateReady(state) {\n    try {\n        // Get the element to replace.\n        const target = this.getElement(this.selectors.EXAMPLE);\n        this.subcomponent = await this.renderComponent(\n            target,\n            'your_plugin/your_template',\n            {\"the\": \"mustache data\"}\n        );\n    } catch (error) {\n        log.error('Cannot load template');\n        throw error;\n    }\n}\n"})})})]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"For renderComponent to work, it is mandatory that the main element of the new component is at the root of the mustache template. Otherwise, the promise won't be resolved. In general, using a first-level node as a main component element is considered best practice in all reactive frameworks (some of them even throw an exception if it is not)."})}),"\n",(0,a.jsx)(t.h2,{id:"start-a-new-reactive-application",children:"Start a new reactive application"}),"\n",(0,a.jsx)(t.p,{children:"Several reactive applications can coexist on the same page. For example, if an activity plugin implements one reactive application it will coexist with the course index, which is also a component but from the course editor reactive application. To ensure component logic doesn't interfere with one another, all the components, mutations, and the reactive state will belong to a specific reactive instance."}),"\n",(0,a.jsx)(t.h3,{id:"general-workflow",children:"General workflow"}),"\n",(0,a.jsx)(t.p,{children:"Every application works in a different way but the process to start a reactive framework is not that different from one another."}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Create the Reactive Instance: for most cases, this will be a singleton where all components, mutations, and components will be registered."}),"\n",(0,a.jsx)(t.li,{children:"Set mutations: this means registering the mutations library into the Reactive Instance. Those are the methods the components can dispatch."}),"\n",(0,a.jsx)(t.li,{children:"Set the initial state: the initial state data can be loaded via a web service or not but the Reactive Instance won't start working until the state is ready."}),"\n",(0,a.jsx)(t.li,{children:"Registering components: components can be registered at any moment. The registration does not depend on the initial state or the mutations. However, the component watchers won't be effective unless the state is ready and the component cannot dispatch mutations if they are not yet loaded."}),"\n",(0,a.jsx)(t.li,{children:"The application is ready to fly."}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"create-the-reactive-instance",children:"Create the Reactive Instance"}),"\n",(0,a.jsx)(t.p,{children:"Creating a Reactive instance is as easy as doing:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"export const myReactiveInstance = new Reactive(description);\n"})}),"\n",(0,a.jsx)(t.p,{children:"However, the description object could have a different number of attributes depending on your need. For example, mutations and the initial state data could be sent at the moment of creation or added later using specific methods."}),"\n",(0,a.jsx)(t.p,{children:"Apart, if your application has some special needs, you may prefer to extend the original Reactive class to create your own (see the extending the reactive class for details)."}),"\n",(0,a.jsx)(t.p,{children:"The description structure:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"eventName"}),": for reactive to work, each instance must provide a custom event name to differentiate from the rest of the instances. This is a mandatory attribute."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"eventDispatch"}),": a method to dispatch the custom event. This is also a mandatory attribute."]}),"\n",(0,a.jsxs)(t.li,{children:["(optional) ",(0,a.jsx)(t.code,{children:"target"}),": an HTML Element in which the reactive instance is active. This is useful when the application will work only in a specific page element like a block. If none is provided the instance will create an invisible node."]}),"\n",(0,a.jsxs)(t.li,{children:["(optional) ",(0,a.jsx)(t.code,{children:"mutations"}),": an object with all the available mutations. This is an optional attribute because the mutations can be overridden (setMutations) or added (addMutations) later."]}),"\n",(0,a.jsxs)(t.li,{children:["(optional) ",(0,a.jsx)(t.code,{children:"state"}),": the initial state data if it is available at the moment of creation. The initial state can only be set one time (it will raise an exception if is done twice). If the application will get the initial state from a web service it must be set later using setInitialState method."]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"implement-mutations-library",children:"Implement mutations library"}),"\n",(0,a.jsx)(t.p,{children:"The Reactive Instance registers all the mutations that components can dispatch. The mutations can be registered:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'At the moment of creating the Reactive instance bypassing the mutation methods as the "mutations" attribute of the description.'}),"\n",(0,a.jsx)(t.li,{children:"Added once the Reactive Instance is created using the reactive setMutations method."}),"\n",(0,a.jsx)(t.li,{children:"If the amount of mutations is large enough to be divided into several files, each of them can be added to the previous mutations using the reactive addMutations method."}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["A mutations library is an object containing all the dispatch methods. Each mutation is free to define its own parameters ",(0,a.jsx)(t.strong,{children:"except for the first one that will be always a StateManager instance"}),". The StateManager object gives access to the state data but, most important, allows the mutation to disable the write mode in order to alter the state."]})}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsxs)("div",{children:[(0,a.jsx)(t.p,{children:'In the "Dispatching mutations from a component" there\'s an example of a component dispatching a mutation called "submitAttempt". The component asks the mutations to the Reactive Instance this way:'}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"this.reactive.dispatch(\u2018submitAttempt\u2019, userid);\n\nA possible code for that mutation can be:\n\nexport default class {\n    async submitAttempt(stateManager, userId) {\n        // Get the state data from the state manager.\n        const state = stateManager.state;\n        (... implement the mutation ...)\n    }\n\n}\n"})})]})]}),"\n",(0,a.jsx)(t.p,{children:"The main goal of mutations is to alter the state. This could be done in two different ways:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Manually altering the state data: assign, delete or create some parts of the state as if it is a regular variable."}),"\n",(0,a.jsx)(t.li,{children:'Call a web service that returns a valid state update message: the State Manager provides a method called "processUpdates" that alters the state following an array of instructions called update message. In those cases the mutation can pass the web service return to the "stateManager.processUpdates" and the manager will handle all the hard work. See the "Controlling the state from the backend" section for more information.'}),"\n"]}),"\n",(0,a.jsx)(t.h4,{id:"manually-altering-the-state",children:"Manually altering the state"}),"\n",(0,a.jsx)(t.p,{children:"All mutations must disable read mode before doing any change to the state data (otherwise it will raise an exception) but, most importantly, it MUST restore the read mode when all the changes are done. The StateManager must guarantee the user interface always represents a stable state so it will not notify the watchers until the read mode is restored."}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsx)("div",{children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="possible implementation of the previous submitAttempt example."',children:"export default class {\n    async submitAttempt(stateManager, userId) {\n        const state = stateManager.state;\n        stateManager.setReadOnly(false);\n        // Call sour webservice.\n        Const result = await ajax.call([{\n            methodname: 'your_plugin_submit_attempt',\n           {userid: userId},\n        }])[0];\n        if (result) {\n            state.students.get(userid).attempts ++;\n        }\n        stateManager.setReadOnly(true);\n    }\n}\n"})})})]}),"\n",(0,a.jsxs)(t.h4,{id:"using-statemanagerprocessupdates-to-alter-the-state",children:["Using ",(0,a.jsx)(t.code,{children:"stateManager.processUpdates"})," to alter the state"]}),"\n",(0,a.jsx)(t.p,{children:"When web services are designed adhoc to serve the reactive application, the backend is fully aware of the state data the frontend must display. In those cases, the mutation method is just a mere intermediary applying the changes."}),"\n",(0,a.jsxs)(t.p,{children:["To prevent the mutations from implementing over and over the same state alterations, the ",(0,a.jsx)(t.code,{children:"StateManager"})," class provides a method called ",(0,a.jsx)(t.code,{children:"processUpdates"}),". That method gets an array of instructions to execute on the state and alters the state notifying the watchers when it finishes."]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsx)("div",{children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:"title=\"supposing 'your_plugin_web_service' returns a valid state update message, a possible mutation can be\"",children:"export default class {\n    async submitAttempt(stateManager, userId) {\n        const state = stateManager.state;\n        Const updates = await ajax.call([{\n            methodname: 'your_plugin_web_service',\n           {userid: userId},\n        }])[0];\n        stateManager.processUpdates(updates);\n    }\n}\n"})})})]}),"\n",(0,a.jsx)(t.p,{children:"As can be seen in the example, the mutation does not need to enable or disable the read mode because the processUpdates will handle it automatically."}),"\n",(0,a.jsx)(t.h4,{id:"private-methods-inside-the-mutations-library",children:"Private methods inside the mutations library"}),"\n",(0,a.jsx)(t.p,{children:'JavaScript is famous for not having private methods. This means all the methods inside the mutations library will be accessible by the Reactive Instance. To prevent components from dispatch private methods the Reactive instance "dispatch" method will raise an expectation in some cases.'}),"\n",(0,a.jsx)(t.p,{children:"Mutation names that components cannot dispatch:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:['The "init" mutation is reserved (see the ',(0,a.jsx)(t.a,{href:"#reserved-init-mutation-method",children:"section below"})," for more information)"]}),"\n",(0,a.jsxs)(t.li,{children:['Any method name starting with "_" is considered private. For example ',(0,a.jsx)(t.code,{children:"_callWebservice"})," is a method that other mutations can use internally but no Component cannot call directly."]}),"\n"]}),"\n",(0,a.jsxs)(t.h4,{id:"reserved-init-mutation-method",children:["Reserved ",(0,a.jsx)(t.code,{children:"init"})," mutation method"]}),"\n",(0,a.jsxs)(t.p,{children:["Each application can use as many mutations as they need. However, there is a reserved mutation called ",(0,a.jsx)(t.code,{children:"init"})," which has a specific meaning. If there is an ",(0,a.jsx)(t.code,{children:"init"})," method in the mutations library the Reactive Component will call it at the moment the mutations are registered."]}),"\n",(0,a.jsx)(t.p,{children:"The init method will receive only the StateManager as a parameter."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"init(stateManager) {\n   // (... code to configure the mutation module or the state manager \u2026)\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This init method can be used to save some global module attributes, load strings, load templates, or configure the state manager ",(0,a.jsx)(t.code,{children:"processUpdates"})," (see ",(0,a.jsx)(t.a,{href:"#controlling-the-state-from-the-backend",children:"Controlling the state from the backend"})," for more information about this last case)."]}),"\n",(0,a.jsx)(t.h3,{id:"set-the-initial-state-data",children:"Set the initial state data"}),"\n",(0,a.jsx)(t.p,{children:"All components from the same Reactive Instance will watch the same state data and react to the changes (see Implementing State Watchers for more information). Even if all the components are registered, the Reactive Instance won't do anything with them until the initial state is loaded."}),"\n",(0,a.jsx)(t.p,{children:"The initial state can only be initialized ones, but it could be done in two different ways:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["If the initial state is available at the moment the Reactive instance is created, it can be passed to the construct method as the ",(0,a.jsx)(t.code,{children:"state"})," attribute in the description param."]}),"\n",(0,a.jsxs)(t.li,{children:["If the state is loaded after the page is rendered (using an ajax call normally) this could be loaded later with the ",(0,a.jsx)(t.code,{children:"setInitialState"})," method."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"When this happens, the components' stateReady hooks will be executed and the watchers will start working."}),"\n",(0,a.jsx)(t.h4,{id:"initial-state-data-limitations",children:"Initial state data limitations"}),"\n",(0,a.jsx)(t.p,{children:"While the JavaScript standard does not offer a suitable native solution for fully reactive data structures, implementing a deep reactive object will be a complex task. Depending on the depth of the changes tracked it will require many frontend resources and many lines of code to maintain. That is the main reason why most people use complex reactive frameworks for it."}),"\n",(0,a.jsx)(t.p,{children:"To keep the state fast and simple, the reactive.js library can only store two kinds of data at the ROOT level:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Objects with attributes of any kind."}),"\n",(0,a.jsxs)(t.li,{children:["Sets (array) of objects with, at least, an ",(0,a.jsx)(t.code,{children:"id"})," attribute. The rest of the attributes of the elements could be as complex as needed. The ",(0,a.jsx)(t.code,{children:"id"})," attribute will be used to index the set."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["This means the following cases are ",(0,a.jsx)(t.strong,{children:"NOT"})," allowed at a state ROOT level (they will raise an exception):"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Simple values (strings, booleans...)."}),"\n",(0,a.jsx)(t.li,{children:"Arrays of simple values."}),"\n",(0,a.jsx)(t.li,{children:"Arrays of objects without ID attribute (all arrays will be converted to maps and require an ID)."}),"\n"]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View valid and invalid examples"}),(0,a.jsxs)("div",{children:[(0,a.jsxs)(u,{children:[(0,a.jsx)(t.p,{children:"Initial state data:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'{\n    "activity": {\n        "name": "Something",\n        "somelist": [1, 42, 23, 56],\n        "info": {\n            "extras": true,\n        },\n    },\n    "students": [\n       {"id": 1, "username": "Jane Doe", "related": [42]},\n       {"id": 2, "username": "John Doe", "related": [42, 56]},\n    ],\n}\n'})})]}),(0,a.jsxs)(d,{children:[(0,a.jsx)(t.p,{children:"Initial state cannot store simple values at root level."}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'{\n    "name": "My incorrect application",\n    "Visible": true,\n}\n'})})]}),(0,a.jsxs)(d,{children:[(0,a.jsx)(t.p,{children:"All initial state root arrays must have an id attribute:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'{\n    "students": [\n       {"username": "Jane Without ID", "related": [42]},\n       {"username": "John Without ID", "related": [42, 56]},\n    ],\n}\n'})})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"controlling-the-state-from-the-backend",children:"Controlling the state from the backend"}),"\n",(0,a.jsx)(t.p,{children:"Most of the time mutations will execute some kind of ajax call to inform the server. The web services for supporting those calls can be generic and return some random data the mutation must interpret to know what state parts must be altered."}),"\n",(0,a.jsx)(t.p,{children:'However, if the web service is aware that it is altering the state, it can send back specific instructions of the state parts that are affected. Those instructions can be executed directly by the State Manager simplifying the mutation code. Those instructions are called "state updates".'}),"\n",(0,a.jsx)(t.h3,{id:"format-of-a-state-update-message",children:"Format of a state update message"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"stateManager.processUpdates"})," can process data structures like:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'[\n    {\n       "name": *THE STATE ELEMENT NAME*,\n       "action": *THE UPDATE TYPE NAME*,\n       "fields": {\n           // ( \u2026 the affected fields of the object \u2026 )\n        }\n    },\n    // (... more actions can be added in a single message ...)\n]\n'})}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"Example of a state update message"}),(0,a.jsx)("div",{children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'[\n    {\n       "name": "students",\n       "action": "put",\n       "fields": {\n           "id": 5,\n           "name": "John Doe",\n           "attempts": 4,\n        }\n    },\n    {\n       "name": "students",\n       "action": "delete",\n       "fields": {\n           "id": 3,\n        }\n    },\n]\n'})})})]}),"\n",(0,a.jsx)(t.p,{children:'The first element of the array will update or create a new element in the "students" set with the fields provided. The second element will remove the element with id 3 from the "students" set.'}),"\n",(0,a.jsx)(t.h3,{id:"available-update-types",children:"Available update types"}),"\n",(0,a.jsx)(t.p,{children:"By default, the state manager can process the following actions:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"put"}),": it is the most common action. Means create or update a state element using the fields provided. If the element exists it will be updated, if not it will be created. IF the element already exists and has some extra fields, they will be preserved as they are."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"override"}),": like ",(0,a.jsx)(t.code,{children:"put"}),", this action will create or update a state element but it will remove any other attribute that is not present in the fields."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"update"}),": will update an element with the fields but it will raise an exception if the element is not in the state."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"create"}),": will create a new state element but it will raise an exception if the element is already created."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"remove"}),": it will delete a state element."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"delete"}),": it will delete a state element but it will raise an exception if the element is not in the state."]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"implementing-custom-update-types",children:"Implementing custom update types"}),"\n",(0,a.jsx)(t.p,{children:'The default update types covers most of the state actions reactive applications should need. However, more update types can be added or even overridden if needed. The State Manager has a method called "addUpdateTypes" that get and object containing all the new update types methods.'}),"\n",(0,a.jsx)(t.p,{children:"Any custom update method will get 3 parameters:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"The state manager instance"}),"\n",(0,a.jsx)(t.li,{children:"The state element name"}),"\n",(0,a.jsx)(t.li,{children:"The fields provided"}),"\n"]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsxs)("div",{children:[(0,a.jsx)(t.p,{children:"A mutations library adding and overriding update types."}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"Const mutations = {\n    init(stateManager) {\n        stateManager.addUpdateTypes({\n            create: this._newCreate,\n            cefreshConcept: this._refreshConcept,\n        });\n    }\n\n    _newCreate(stateManager, name, fields) {\n        fields.timeCreated = Date.now();\n        stateManager.defaultCreate(stateManager, name, fields);\n    }\n\n    _refreshConcept(stateManager, name, fields) {\n        const state = stateManager.state;\n        stateManager.setReadOnly(false);\n        // Do some stuff with the state.\n        State.activity.notice = `A refresh context of ${name} with ${fields.something} arrived`;\n        // Restore the state read mode to alert watchers.\n        stateManager.setReadOnly(true);\n    }\n};\n"})}),(0,a.jsxs)(t.admonition,{type:"note",children:[(0,a.jsx)(t.p,{children:"In that example:"}),(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"The mutation init method adds overrides the default create action and a new refreshConcept."}),"\n",(0,a.jsxs)(t.li,{children:["If the backend sends an update message with ",(0,a.jsx)(t.code,{children:"create"})," as action, the _newCreate will be executed."]}),"\n",(0,a.jsxs)(t.li,{children:["If the backend sends an update message with ",(0,a.jsx)(t.code,{children:"refreshConcept"}),", the ",(0,a.jsx)(t.code,{children:"_refreshConcept"})," will be executed."]}),"\n",(0,a.jsx)(t.li,{children:"Any other action like put, delete, or update will continue working as before using the state manager defaults."}),"\n"]})]})]})]}),"\n",(0,a.jsx)(t.h3,{id:"adding-default-values-to-state-attributes",children:"Adding default values to state attributes"}),"\n",(0,a.jsx)(t.p,{children:"There are cases in which the fields of the update message are exactly the ones stored in the state. Some of the examples of it could be when:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The state has attributes that only live in the frontend and won't be provided by the backend. For example, a ",(0,a.jsx)(t.em,{children:"locked"})," attribute locks user interactions when the element is pending some updates."]}),"\n",(0,a.jsx)(t.li,{children:"The returned fields have some information that is only for the mutation, like adding some small chunk of HTML or some pre-loaded strings that do not need to be in the state all the time."}),"\n",(0,a.jsx)(t.li,{children:"Some of the state attributes are calculated in the front end using the provided element fields."}),"\n",(0,a.jsx)(t.li,{children:"Some element attributes have default values that the backend can omit to optimize the returned message size."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["For those scenarios, there's a reserved action called ",(0,a.jsx)(t.code,{children:"prepareFields"}),". The state manager will use this method to convert the fields provided to valid state objects."]}),"\n",(0,a.jsx)(t.p,{children:"The prepareFields method will return get the following parameters:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.code,{children:"StateManager"})," object to access the full state"]}),"\n",(0,a.jsxs)(t.li,{children:["The state element name ",(0,a.jsx)(t.code,{children:"elementName"})]}),"\n",(0,a.jsxs)(t.li,{children:["An object with the ",(0,a.jsx)(t.code,{children:"fields"})," provided"]}),"\n"]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsxs)("div",{children:[(0,a.jsx)(t.p,{children:"A possible prepareFields update type:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"prepareFields(stateManager, updateName, fields) {\n    const state = stateManager.state;\n    fields.extras = state.activity.extras && fields.extras;\n    return fields;\n}\n"})})]})]}),"\n",(0,a.jsx)(t.h2,{id:"drag--drop-helper-component",children:"Drag & drop helper component"}),"\n",(0,a.jsxs)(t.p,{children:["Components can delegate parts of the logic to other components. In case a component wants to implement a draggable element or a drop-zone, it can delegate all the configuration stuff to a ",(0,a.jsx)(t.code,{children:"DragDrop"})," component exported in the ",(0,a.jsx)(t.code,{children:"core/reactive"})," module."]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"DragDrop"})," class will do all the HTML setup and leave only the custom logic to the parent component. The only restriction is that a draggable element will only interact with dop-zones registered in the same reactive instance. This way, if two applications has draggable elements in the same page each one will interact only with the proper ones."]}),"\n",(0,a.jsx)(t.p,{children:"In general, any draggable or drop-zone component will follow the same schema."}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsx)("div",{children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {BaseComponent, DragDrop} from 'core/reactive';\n\nexport default class extends BaseComponent {\n    /**\n     * The state is ready.\n     */\n    stateReady() {\n        this.dragdrop = new DragDrop(this);\n    }\n\n    /**\n     * Remove all subcomponents dependencies.\n     */\n    destroy() {\n        // The draggable element must be unregistered.\n        if (this.dragdrop !== undefined) {\n            this.dragdrop.unregister();\n        }\n    }\n\n    // (... implement all the draggable or drop-zone required methods...)\n}\n"})})})]}),"\n",(0,a.jsx)(t.h3,{id:"implementing-a-draggable-element",children:"Implementing a draggable element"}),"\n",(0,a.jsxs)(t.p,{children:["Making a standard component draggable is easy. If the parent component has a ",(0,a.jsx)(t.code,{children:"getDraggableData"})," the ",(0,a.jsx)(t.code,{children:"dragdrop"})," component will set up the draggable element automatically."]}),"\n",(0,a.jsx)(t.p,{children:"Draggable methods:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"getDraggableData(): Object|null"})," this is the only mandatory method for a draggable element. The ",(0,a.jsx)(t.code,{children:"dragdrop"})," will use this method to get the data to pass to the valid drop-zones. If the method returns a null or undefined, the dragging will ignore the dragging action."]}),"\n",(0,a.jsxs)(t.li,{children:["(optional) ",(0,a.jsx)(t.code,{children:"dragStart(Object dragData, Event event): void"})," the parent class can implement this method to capture the dragStart event."]}),"\n",(0,a.jsxs)(t.li,{children:["(optional) ",(0,a.jsx)(t.code,{children:"dragEnd(Object dragData, Event event): void"})," the parent class can implement this method to capture the dragEnd event"]}),"\n"]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsxs)("div",{children:[(0,a.jsx)(t.p,{children:"This is a basic example of a draggable component."}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {BaseComponent, DragDrop} from 'core/reactive';\n\nexport default class extends BaseComponent {\n    /**\n     * The state is ready.\n     */\n    stateReady() {\n        this.dragdrop = new DragDrop(this);\n    }\n\n    /**\n     * Remove all subcomponents dependencies.\n     */\n    destroy() {\n        // The draggable element must be unregistered.\n        if (this.dragdrop !== undefined) {\n            this.dragdrop.unregister();\n        }\n    }\n\n    /**\n     * Get the draggable data of this component.\n     *\n     * @returns {Object} the draggable data.\n     */\n    getDraggableData() {\n        // This data will be passed to the drop-zones.\n        return {id: 35, name: \"Something\"};\n    }\n}\n"})}),(0,a.jsxs)(t.admonition,{type:"note",children:[(0,a.jsxs)(t.p,{children:["As can be seen in th example, no event handling is required. By default, the ",(0,a.jsx)(t.code,{children:"DragDrop"})," element will switch on and off some CSS classes if the element is dragged or dropped:"]}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"draggable"}),": this class is added to the ",(0,a.jsx)(t.code,{children:"this.element"})," when the draggable setup is finished."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"dragging"}),": this class is added when the user drags the element and is removed when it is dropped."]}),"\n"]})]})]})]}),"\n",(0,a.jsx)(t.h3,{id:"implementing-a-drop-zone-component",children:"Implementing a drop-zone component"}),"\n",(0,a.jsxs)(t.p,{children:["Drop-zones are implemented similarly to the draggable elements. The DragDrop component will set up the ",(0,a.jsx)(t.code,{children:"this.element"})," as a drop-zone depending on the methods of the parent component."]}),"\n",(0,a.jsx)(t.p,{children:"Drop-zone methods:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"validateDropData(Object dropdata): boolean"})," each time a dragged element passes through a drop-zone, the DragDrop component will call this method to decide if the dragged element is valid for this drop-zone."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"drop(Object dropdata): void"})," will be called only if a valid draggable data is dropped in the drop-zone. Important: the drop method should not re-validate the dragged data because the ",(0,a.jsx)(t.code,{children:"DragDrop"})," will always call that handler after validateDropData, and only if it returns true."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"(optional) hideDropZone (Object dragdata, Event event): void"})," will be executed when valid drag data (validateDropData returns true) enters the drop-zone. This method is used to add visual clues to the user that this is a drop-zone."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"(optional) hideDropZone (Object dragdata, Event event): void"})," will be executed when valid drag data (validateDropData returns true) leaves the drop-zone. This method is used to remove visual clues to the user that this is a drop-zone."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"DragDrop"})," element will switch on and off some CSS classes of the drop-zones:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"dropready"}),": added when the drop--zone setup finishes"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"dragover"}),": added or removed when a valid draggable element enter or exits the drop-zone"]}),"\n"]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"View example"}),(0,a.jsxs)("div",{children:[(0,a.jsx)(t.p,{children:"This is a basic example of a drop-zone component."}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'import {BaseComponent, DragDrop} from \'core/reactive\';\n\nexport default class extends BaseComponent {\n    /**\n     * The state is ready.\n     */\n    stateReady() {\n        this.dragdrop = new DragDrop(this);\n    }\n\n    /**\n     * Remove all subcomponents dependencies.\n     */\n    destroy() {\n        // The draggable element must be unregistered.\n        if (this.dragdrop !== undefined) {\n            this.dragdrop.unregister();\n        }\n    }\n\n    /**\n     * Validate draggable data.\n     *\n     * @returns {boolean} if the data is valid for this drop-zone.\n     */\n    validateDropData(dropdata) {\n        // we don\u2019t want grumpy data in this drop-zone ;-)\n        return dropdata?.name != \u2018Grumpy\u2019;\n    }\n\n\n\n    /**\n     * Executed when a valid dropdata is dropped over the drop-zone.\n     */\n    drop(dropdata, event) {\n        // We don\u2019t need to check again for grumpy data\n        // because it is already done.\n        // (... some logic sending the dropdata to the server or whatever...)\n    }\n\n    /**\n     * Optional method to show some visual hints to the user.\n     */\n    showDropZone(dropdata, event) {\n        this.element.innerHTML = "DROP HERE!";\n    }\n\n    /**\n     * Optional method to remove visual hints to the user.\n     */\n    hideDropZone(dropdata, event) {\n        this.element.innerHTML = "DROP ZONE";\n    }\n}\n'})})]})]})]})}function m(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}function p(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},85647:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/basic_classes-6e4db1badfba456e6a0bb6692d800390.svg"},93793:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/lifecycle_hooks-105205369fcd0a243eca27c6fae6973b.svg"}}]);