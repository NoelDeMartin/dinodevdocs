"use strict";(self.webpackChunkdevdocs=self.webpackChunkdevdocs||[]).push([[50713],{15653:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=t(74848),s=t(28453),o=t(78924);const a={title:"Moodle App Development Guide",sidebar_label:"Development guide",sidebar_position:2,tags:["Moodle App"]},r=void 0,l={id:"app/development/development-guide",title:"Moodle App Development Guide",description:"This document contains information that developers should know before starting to code on the Mobile App. If you are only interested in developing a site plugin, you should read the Moodle App Plugins development guide instead.",source:"@site/general/app/development/development-guide.md",sourceDirName:"app/development",slug:"/app/development/development-guide",permalink:"/moodledevdocs/general/app/development/development-guide",draft:!1,unlisted:!1,editUrl:"https://github.com/moodle/devdocs/edit/main/general/app/development/development-guide.md",tags:[{label:"Moodle App",permalink:"/moodledevdocs/general/tags/moodle-app"}],version:"current",lastUpdatedBy:"Noel De Martin",lastUpdatedAt:1719423631e3,sidebarPosition:2,frontMatter:{title:"Moodle App Development Guide",sidebar_label:"Development guide",sidebar_position:2,tags:["Moodle App"]},sidebar:"moodleapp",previous:{title:"Troubleshooting",permalink:"/moodledevdocs/general/app/development/setup/troubleshooting"},next:{title:"Plugins development guide",permalink:"/moodledevdocs/general/app/development/plugins-development-guide/"}},d={},c=[{value:"Setting up your development environment",id:"setting-up-your-development-environment",level:2},{value:"Editing code",id:"editing-code",level:3},{value:"Debugging",id:"debugging",level:3},{value:"Working with a Moodle site",id:"working-with-a-moodle-site",level:3},{value:"Working on native functionality",id:"working-on-native-functionality",level:3},{value:"Folders structure",id:"folders-structure",level:2},{value:"index.html",id:"indexhtml",level:3},{value:"main.ts",id:"maints",level:3},{value:"polyfills.ts",id:"polyfillsts",level:3},{value:"app/",id:"app",level:3},{value:"core/",id:"core",level:3},{value:"core/initializers/",id:"coreinitializers",level:4},{value:"core/services/",id:"coreservices",level:4},{value:"core/components/",id:"corecomponents",level:4},{value:"core/directives/ and core/pipes/",id:"coredirectives-and-corepipes",level:4},{value:"core/guards/",id:"coreguards",level:4},{value:"core/classes/",id:"coreclasses",level:4},{value:"core/utils/",id:"coreutils",level:4},{value:"core/singletons/",id:"coresingletons",level:4},{value:"core/features/",id:"corefeatures",level:4},{value:"addons/",id:"addons",level:3},{value:"types/",id:"types",level:3},{value:"testing/",id:"testing",level:3},{value:"theme/",id:"theme",level:3},{value:"assets/",id:"assets",level:3},{value:"File names",id:"file-names",level:3},{value:"Language files",id:"language-files",level:3},{value:"Constants files",id:"constants-files",level:3},{value:"Test files",id:"test-files",level:3},{value:"Routing",id:"routing",level:2},{value:"Dynamic Routes",id:"dynamic-routes",level:3},{value:"Split View Routes",id:"split-view-routes",level:3},{value:"Navigating between routes",id:"navigating-between-routes",level:3},{value:"Navigating using swipe gestures",id:"navigating-using-swipe-gestures",level:3},{value:"Singletons",id:"singletons",level:2},{value:"Pure Singletons",id:"pure-singletons",level:3},{value:"Service Singletons",id:"service-singletons",level:3},{value:"Database",id:"database",level:2},{value:"Schema migrations",id:"schema-migrations",level:3},{value:"Legacy",id:"legacy",level:3},{value:"Application Lifecycle",id:"application-lifecycle",level:2},{value:"Testing",id:"testing-1",level:2},{value:"Unit",id:"unit",level:3},{value:"Acceptance",id:"acceptance",level:3},{value:"See also",id:"see-also",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(o.A,{frontMatter:a,metadata:l}),"\n",(0,i.jsxs)(n.p,{children:["This document contains information that developers should know before starting to code on the Mobile App. If you are only interested in developing a site plugin, you should read ",(0,i.jsx)(n.a,{href:"/moodledevdocs/general/app/development/plugins-development-guide/",children:"the Moodle App Plugins development guide"})," instead."]}),"\n",(0,i.jsx)(n.p,{children:"Please notice that this documentation is useful to develop code that will be integrated in the standard app or in a custom app. Developers that want to add mobile support to their Moodle plugins don't need to follow this."}),"\n",(0,i.jsx)(n.admonition,{title:"Notice",type:"note",children:(0,i.jsxs)(n.p,{children:["Before embarking on Moodle-specific documentation, we recommend that you are at least familiar with ",(0,i.jsx)(n.a,{href:"https://angular.io/",children:"Angular"})," and ",(0,i.jsx)(n.a,{href:"https://ionicframework.com/",children:"Ionic Framework"}),", the core technologies used in the application. We'll reference any relevant concepts, but having a basic understanding will take you a long way in understanding the Moodle App."]})}),"\n",(0,i.jsx)(n.h2,{id:"setting-up-your-development-environment",children:"Setting up your development environment"}),"\n",(0,i.jsx)(n.p,{children:"In order to get started, you'll need to prepare your development environment. We recommend that you do it before proceeding with the guide, that way you can tinker with the codebase to solidify your understanding."}),"\n",(0,i.jsxs)(n.p,{children:["You can obtain a copy of the source code by cloning the public repository. If you want to work on a specific version of the app, you can check the tag with the version number you need; for example ",(0,i.jsx)(n.code,{children:"v3.9.5"}),". If you want to work on the latest development version, you should check out the ",(0,i.jsx)(n.code,{children:"main"})," branch:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"git clone git@github.com:moodlehq/moodleapp.git\ncd moodleapp\ngit checkout main # or `git checkout v3.9.5`\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The only things you need to install before running the app are NodeJS and npm. Make sure that you are using the correct versions of each environment (looking at the ",(0,i.jsx)(n.code,{children:"engines"})," entry in ",(0,i.jsx)(n.code,{children:"package.json"}),"). We recommend using a version manager like ",(0,i.jsx)(n.a,{href:"https://github.com/nvm-sh/nvm",children:"nvm"})," to make this easier, you can prepare the correct environment running ",(0,i.jsx)(n.code,{children:"nvm install"})," in the project root. Remember to run this every time you work with the app, or if you're not working on any other node projects in your computer you can run ",(0,i.jsx)(n.code,{children:"nvm alias default `node -v` "})," to make it the default."]}),"\n",(0,i.jsx)(n.p,{children:"Once you have the correct environment set up, you can run the application with the following two commands:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"npm install\nnpm start\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This will launch the application in a browser, but keep in mind that it only works with chromium-based browsers. You can read more about that in the ",(0,i.jsx)(n.a,{href:"/moodledevdocs/general/app/development/setup/app-in-browser",children:"Using the Moodle App in a browser"})," page."]}),"\n",(0,i.jsxs)(n.p,{children:["Other than this, there are different things you'll need to do depending on what you are trying to achieve. We'll go over some of them briefly, but if you want to learn more about this or something isn't working as you expect, make sure to check out the full guide on ",(0,i.jsx)(n.a,{href:"/moodledevdocs/general/app/development/setup/",children:"Setting up your development environment for the Moodle App"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"editing-code",children:"Editing code"}),"\n",(0,i.jsx)(n.p,{children:"You can use your favorite editor to work on the application."}),"\n",(0,i.jsxs)(n.p,{children:["We recommend using ",(0,i.jsx)(n.a,{href:"https://code.visualstudio.com/",children:"VSCode"})," as it is the one used by the core team and the repository is configured with some specific settings for the Moodle App."]}),"\n",(0,i.jsxs)(n.p,{children:["The code follows the ",(0,i.jsx)(n.a,{href:"/moodledevdocs/general/development/policies/codingstyle-moodleapp",children:"Moodle App Coding Style"}),", and many of the style rules are enforced with ",(0,i.jsx)(n.a,{href:"https://eslint.org/",children:"ESLint"}),". If you are using VSCode, you can automatically lint your files using the ",(0,i.jsx)(n.a,{href:"https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint",children:"ESLint extension"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"debugging",children:"Debugging"}),"\n",(0,i.jsx)(n.p,{children:"While working on the app, you'll want to debug what's going on under the hood. The application uses a logging mechanism to inform of what's happening, so if you open the console during development you will see a bunch of messages that you may find useful."}),"\n",(0,i.jsxs)(n.p,{children:["If you are working on something related with the user interface, it is useful to inspect the state of the Angular components in the page. You can do that using the ",(0,i.jsx)(n.a,{href:"https://github.com/anton-lunev/angular-state-inspector",children:"Angular State Inspection browser extension"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If you are working on something that is pure logic (although it can involve components), you may want to give ",(0,i.jsx)(n.a,{href:"#unit",children:"unit testing"})," a try. If you are ",(0,i.jsx)(n.a,{href:"https://code.visualstudio.com/Docs/editor/debugging",children:"using VSCode to run the tests"}),", you can use breakpoints right on your editor. If you are struggling to reproduce an issue in tests, you can also use breakpoints in the browser ",(0,i.jsx)(n.a,{href:"https://developer.chrome.com/docs/devtools/javascript/",children:"using the Sources Panel"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If you need to debug how the application is interacting with a Moodle site, you'll need to take a look at the network requests. Most of the time ",(0,i.jsx)(n.a,{href:"https://developer.chrome.com/docs/devtools/network/",children:"using the Network Panel"})," should suffice, but if that isn't working take a look at the ",(0,i.jsx)(n.a,{href:"/moodledevdocs/general/app/development/network-debug",children:"Debugging network requests in the Moodle App"})," page."]}),"\n",(0,i.jsx)(n.h3,{id:"working-with-a-moodle-site",children:"Working with a Moodle site"}),"\n",(0,i.jsx)(n.p,{children:"When you are using the app, you'll need to connect with a Moodle site. You may already have your own site, but using a real site may not be the best choice for development."}),"\n",(0,i.jsxs)(n.p,{children:["If you're working on something that doesn't need anything specific from your site, you can use a test site like ",(0,i.jsx)(n.a,{href:"https://school.moodledemo.net",children:"school.moodledemo.net"}),". This is a site that will reset all the data every hour, so you don't have to worry about making any persistent change by mistake. You can also use a shortcut to log in as a student or teacher using ",(0,i.jsx)(n.code,{children:"student"})," or ",(0,i.jsx)(n.code,{children:"teacher"})," instead of a url. However, keep in mind that this site is also used by others who are new to Moodle, so be sensible and don't abuse it."]}),"\n",(0,i.jsxs)(n.p,{children:["If you need to configure something from the site, your best option is to run a Moodle site on your computer. Setting that up is outside the scope of this document, but we recommend using ",(0,i.jsx)(n.a,{href:"https://github.com/moodlehq/moodle-docker",children:"moodle-docker"})," because it comes with everything you need (and it also supports running the app!). If you need anything specific from a course, you can always replicate it on your local site using the ",(0,i.jsx)(n.a,{href:"https://docs.moodle.org/311/en/Backup",children:"backup and restore functionality"}),". You can create a backup from your production site, and restore it in your local site."]}),"\n",(0,i.jsx)(n.h3,{id:"working-on-native-functionality",children:"Working on native functionality"}),"\n",(0,i.jsx)(n.p,{children:"Most of the time, we recommend that you develop using a browser because it's faster and easier to work with. However, sometimes you may need native functionality that is only available on a mobile device."}),"\n",(0,i.jsxs)(n.p,{children:["You can learn how to set up your environment by reading Ionic's documentation for ",(0,i.jsx)(n.a,{href:"https://ionicframework.com/docs/developing/android",children:"Android"})," and ",(0,i.jsx)(n.a,{href:"https://ionicframework.com/docs/developing/ios",children:"iOS"}),". The Moodle App also comes with some npm scripts used for native development. You can build and launch the app by calling ",(0,i.jsx)(n.code,{children:"npm run dev:android"})," and ",(0,i.jsx)(n.code,{children:"npm run dev:ios"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"folders-structure",children:"Folders structure"}),"\n",(0,i.jsxs)(n.p,{children:["In this section, we'll see how files and folders are organised within the ",(0,i.jsx)(n.code,{children:"src/"})," folder."]}),"\n",(0,i.jsx)(n.h3,{id:"indexhtml",children:"index.html"}),"\n",(0,i.jsx)(n.p,{children:"This html file contains the shell where the application will be rendered. Before the app is ready, even before JavaScript is loaded, this is what the application will look like. In a mobile device, users will never see this because it is hidden by the splash screen until the application is ready. That's why there isn't any markup other than the root component that will be rendered by Angular."}),"\n",(0,i.jsxs)(n.p,{children:["You won't see any script files referenced here because those are injected later in the compilation process. You can see the actual file in the ",(0,i.jsx)(n.code,{children:"www/"})," folder after running the build script."]}),"\n",(0,i.jsx)(n.h3,{id:"maints",children:"main.ts"}),"\n",(0,i.jsx)(n.p,{children:"This file is the main entry point of the application, the first code that runs when the application is launched. The application is bootstrapped by Angular using our root application module."}),"\n",(0,i.jsxs)(n.p,{children:["You can learn more about this in the ",(0,i.jsx)(n.a,{href:"#application-lifecycle",children:"Application Lifecycle"})," section."]}),"\n",(0,i.jsx)(n.h3,{id:"polyfillsts",children:"polyfills.ts"}),"\n",(0,i.jsxs)(n.p,{children:["This file adds ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Polyfill_(programming)",children:"polyfills"})," for missing functionality in the platform."]}),"\n",(0,i.jsx)(n.h3,{id:"app",children:"app/"}),"\n",(0,i.jsx)(n.p,{children:"This folder contains the root component and the root module of the application."}),"\n",(0,i.jsxs)(n.p,{children:["You will notice that the app.module.ts file is quite small. This is because it only includes Angular and Ionic boilerplate, leaving the heavy lifting to the code within ",(0,i.jsx)(n.a,{href:"#core",children:"core/"})," and ",(0,i.jsx)(n.a,{href:"#addons",children:"addons/"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"core",children:"core/"}),"\n",(0,i.jsxs)(n.p,{children:["This folder contains the basic functionality of the application, and exposes pluginable interfaces for other parts to hook into. Anything defined here can be imported anywhere since it's critical for the app and it is available everywhere (in contrast to code within ",(0,i.jsx)(n.a,{href:"#addons",children:"addons/"}),"). In order to identify code from this folder, all classes start with the ",(0,i.jsx)(n.code,{children:"Core"})," prefix."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"core.module.ts"})," file defines a module that imports all the core providers and modules. It encapsulates the initialisation of the application core."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"shared.module.ts"})," file defines a ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/module-types#shared-ngmodules",children:"Shared Module"})," that exposes core declarables (components, directives and pipes). When other modules use any of these, it's preferable to import this module instead of individual declarable modules separately."]}),"\n",(0,i.jsxs)(n.p,{children:["There is also a ",(0,i.jsx)(n.code,{children:"constants.ts"})," file which should follow the conventions for ",(0,i.jsx)(n.a,{href:"#constants-files",children:"constants files"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"coreinitializers",children:"core/initializers/"}),"\n",(0,i.jsxs)(n.p,{children:["This folder contains a collection of scripts that are run within the ",(0,i.jsx)(n.a,{href:"https://angular.io/api/core/APP_INITIALIZER",children:"Angular initialisation process"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["These files are automatically loaded using webpack, so it isn't necessary to import them anywhere. You can see how they are loaded in ",(0,i.jsx)(n.code,{children:"src/core/initializers/index.ts"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Keep in mind that any code placed here will delay the ",(0,i.jsx)(n.a,{href:"#application-lifecycle",children:"application startup"}),", so it's critical that only the essential processes are included here. If something can be initialised lazily, it should."]}),"\n",(0,i.jsx)(n.h4,{id:"coreservices",children:"core/services/"}),"\n",(0,i.jsxs)(n.p,{children:["This folder contains ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/architecture-services",children:"Angular services"})," available anywhere in the application."]}),"\n",(0,i.jsxs)(n.p,{children:["Most of them are ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/singleton-services",children:"Singleton Services"}),", and they can be accessed statically using their corresponding ",(0,i.jsx)(n.a,{href:"#service-singletons",children:"Service Singleton"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Given that services are created on demand, none of them is guaranteed to be initialised when the application is ready. So anything that's essential for the application to run should be placed in an ",(0,i.jsx)(n.a,{href:"#coreinitializers",children:"initializer"})," instead. In case that the initialisation relies on a service, it can be accessed using its Service Singleton. One good example of this is the database initialisation, which is placed on an initializer but calls each service's ",(0,i.jsx)(n.code,{children:"initializeDatabase"})," method."]}),"\n",(0,i.jsx)(n.p,{children:"And of course, service dependencies can be declared in the constructor to use Angular's built-in dependency management."}),"\n",(0,i.jsx)(n.h4,{id:"corecomponents",children:"core/components/"}),"\n",(0,i.jsxs)(n.p,{children:["This folder contains ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/architecture-components",children:"Angular components"})," available anywhere in the application (but remember that they should be imported explicitly using ",(0,i.jsx)(n.code,{children:"CoreSharedModule"}),"). They are exposed to the shared module using their own module: ",(0,i.jsx)(n.code,{children:"CoreComponentsModule"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This folder also contains an ",(0,i.jsx)(n.code,{children:"animations.ts"})," file with reusable ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/animations",children:"Angular animations"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["All components must be declared with tag selectors starting with their module namespace (",(0,i.jsx)(n.em,{children:"core-"})," in this case), and defined within a folder with their selector (without the namespace prefix). These component folders can contain the following files:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"{component-name}.ts"})," \u2014 Component class."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"{namespace}-{component-name}.html"})," \u2014 Component template."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"{component-name}.scss"})," \u2014 Component-scoped styles."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Additionally, auxiliary components that are only used locally can be defined in the same folder, starting with the name of their parent component. For example, looking at the ",(0,i.jsx)(n.code,{children:"core-recaptcha"})," component we can find the following files:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"recaptcha.ts"})," \u2014 Recaptcha component class."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"core-recaptcha.html"})," \u2014 Recaptcha component template."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"recaptcha-modal.ts"})," \u2014 Auxiliary modal component class."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"core-recaptcha-modal.html"})," \u2014 Auxiliary modal component template."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"coredirectives-and-corepipes",children:"core/directives/ and core/pipes/"}),"\n",(0,i.jsxs)(n.p,{children:["These folders contain ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/architecture-components#directives",children:"Angular directives"})," and ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/architecture-components#pipes",children:"Angular pipes"})," available anywhere in the application (but remember that they should be imported explicitly using ",(0,i.jsx)(n.code,{children:"CoreSharedModule"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["They are exposed to the shared module using their own modules: ",(0,i.jsx)(n.code,{children:"CoreDirectivesModule"})," and ",(0,i.jsx)(n.code,{children:"CorePipesModule"})," respectively."]}),"\n",(0,i.jsx)(n.h4,{id:"coreguards",children:"core/guards/"}),"\n",(0,i.jsxs)(n.p,{children:["This folder contains ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/router#preventing-unauthorized-access",children:"route guards"})," used to control access to restricted routes."]}),"\n",(0,i.jsx)(n.p,{children:"Given that we are working with a mobile application, and not deploying to the web, users won't be able to access urls manually. But it is still important to have proper guards to prevent potential bugs and vulnerabilities."}),"\n",(0,i.jsx)(n.h4,{id:"coreclasses",children:"core/classes/"}),"\n",(0,i.jsx)(n.p,{children:"This folder contains classes that don't fit into any other part of the application. We must be careful not to bloat this folder and turn it into a mess. There can be subfolders to group files with related functionality."}),"\n",(0,i.jsx)(n.p,{children:"Think twice before adding anything here."}),"\n",(0,i.jsx)(n.h4,{id:"coreutils",children:"core/utils/"}),"\n",(0,i.jsxs)(n.p,{children:["Same as ",(0,i.jsx)(n.a,{href:"#coreclasses",children:"core/classes/"}),", but containing functional utilities instead of classes."]}),"\n",(0,i.jsx)(n.h4,{id:"coresingletons",children:"core/singletons/"}),"\n",(0,i.jsxs)(n.p,{children:["This folder contains some core ",(0,i.jsx)(n.a,{href:"#singletons",children:"Singletons"})," and the logic to make Service Singletons."]}),"\n",(0,i.jsx)(n.p,{children:"Other than Pure Singletons, there are also some third-party services exposed through Service Singletons. However, service Singletons for application services should be declared in the same file where the service is defined."}),"\n",(0,i.jsx)(n.h4,{id:"corefeatures",children:"core/features/"}),"\n",(0,i.jsxs)(n.p,{children:["This folder contains ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/module-types#domain-ngmodules",children:"Domain Modules"})," for core features. Each of those modules encapsulates the functionality for a given area. Even though they can rely on each other (because anything within core is globally accessible), it should be avoided to reduce coupling."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"features.module.ts"})," file defines a module that imports all feature modules."]}),"\n",(0,i.jsx)(n.p,{children:"Each feature module will be different, some may only provide services while others define routing endpoints (or both). In any case, each feature is encapsulated into its own folder."}),"\n",(0,i.jsxs)(n.p,{children:["When a module needs to export something, it has a file in its root folder named ",(0,i.jsx)(n.code,{children:"{feature-name}.module.ts"})," defining the main feature module."]}),"\n",(0,i.jsxs)(n.p,{children:["If a module uses ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/lazy-loading-ngmodules",children:"lazy loading"}),", that will be declared within a different module defined in ",(0,i.jsx)(n.code,{children:"{feature-name}-lazy.module.ts"}),", and the lazy routes are exposed through the main feature module. In this way, the knowledge of which routes are loaded lazily is encapsulated within each feature folder."]}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes, it's possible that a feature allows nested routes to be defined from other modules. For example, the ",(0,i.jsx)(n.em,{children:"mainmenu"})," feature allows other modules to add extra tabs. In those situations, these features will also have a ",(0,i.jsx)(n.code,{children:"{feature-name}-routing.module.ts"})," file."]}),"\n",(0,i.jsxs)(n.p,{children:["You can learn more about the contents and motivation of these files in the ",(0,i.jsx)(n.a,{href:"#routing",children:"Routing"})," section."]}),"\n",(0,i.jsx)(n.p,{children:"In addition to these files, feature folders may contain the following:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"{feature-name}.scss"})," \u2014 Reusable styles for components defined in this module."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"classes/"})," \u2014 Same as ",(0,i.jsx)(n.a,{href:"#coreclasses",children:"core/classes/"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"utils/"})," \u2014 Same as ",(0,i.jsx)(n.a,{href:"#coreutils",children:"core/utils/"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"components/"})," \u2014 Same as ",(0,i.jsx)(n.a,{href:"#corecomponents",children:"core/components/"})," (with the ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.code,{children:"core-{feature-name}-"})})," namespace)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"directives/"})," and ",(0,i.jsx)(n.code,{children:"pipes/"})," \u2014 Same as ",(0,i.jsx)(n.a,{href:"#coredirectives-and-corepipes",children:"core/directives/ and core/pipes/"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lang.json"})," \u2014 See ",(0,i.jsx)(n.a,{href:"#language-files",children:"Language files"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"constants.ts"})," \u2014 See ",(0,i.jsx)(n.a,{href:"#constants-files",children:"Constants files"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"services/"})," \u2014 Same as ",(0,i.jsx)(n.a,{href:"#coreservices",children:"core/services/"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pages/"})," \u2014 Page folders have the same structure as ",(0,i.jsx)(n.a,{href:"#corecomponents",children:"core/components/"}),", but in addition they can declare modules if a page component is to be used in more than one module. Also, page components will declare their selectors starting with ",(0,i.jsx)(n.code,{children:"page-"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In order to distinguish code from each feature, classes will be prefixed with the feature name. For example, the home page component declared in ",(0,i.jsx)(n.code,{children:"core/features/mainmenu/pages/home/home.ts"})," is called ",(0,i.jsx)(n.code,{children:"CoreMainMenuHomePage"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"addons",children:"addons/"}),"\n",(0,i.jsxs)(n.p,{children:["This folder contains ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/module-types#domain-ngmodules",children:"Domain Modules"})," for additional features. Its structure is similar to ",(0,i.jsx)(n.a,{href:"#corefeatures",children:"core/features/"}),", but the namespace is ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.code,{children:"addon-{addon-name}-"})})," and addon modules are decoupled from core and each other. This means that any code within core shouldn't import anything from addons, and addons shouldn't import anything from each other."]}),"\n",(0,i.jsxs)(n.p,{children:["This level of decoupling can be achieved using the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Dependency_inversion_principle",children:"Dependency Inversion Principle"}),", which in this case is easier to apply using ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/dependency-injection",children:"Angular's Dependency Injection framework"}),". However, this theoretical nirvana has not been achieved in the current status of the codebase. And it's arguable whether it is desirable, given the cost of adhering strictly to this pattern."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, calendar blocks defined in the ",(0,i.jsx)(n.em,{children:"block"})," addon import a provider declared in the ",(0,i.jsx)(n.em,{children:"calendar"})," addon. This violates the dependency inversion principle, but it's a sensible decision to avoid complicating the code in excess."]}),"\n",(0,i.jsx)(n.p,{children:"The end goal is to make each addon as independent as possible, keeping practicality and simplicity in mind."}),"\n",(0,i.jsxs)(n.p,{children:["In order to distinguish code from each addon, classes will be prefixed with ",(0,i.jsx)(n.em,{children:"Addon"})," + the addon name. For example, the private files page component declared in ",(0,i.jsx)(n.code,{children:"core/addons/privatefiles/pages/index/index.ts"})," is called ",(0,i.jsx)(n.code,{children:"AddonPrivateFilesIndexPage"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"types",children:"types/"}),"\n",(0,i.jsxs)(n.p,{children:["This folder contains global ",(0,i.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html",children:"TypeScript declaration files"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"testing",children:"testing/"}),"\n",(0,i.jsxs)(n.p,{children:["This folder contains supporting code for writing tests, but does not contain any tests. To learn where tests are located, read the ",(0,i.jsx)(n.a,{href:"#test-files",children:"Test files"})," section."]}),"\n",(0,i.jsx)(n.h3,{id:"theme",children:"theme/"}),"\n",(0,i.jsx)(n.p,{children:"This folder contains general app style sheets. theme.scss is the one that will be included in the html, the rest will be imported by theme or children of this."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"theme.scss"})," \u2014 This is the main file and contains imports to the rest of the files and 3rd party styles."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"theme.light.scss"})," \u2014 Includes the desired variables for the light color scheme."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"theme.dark.scss"})," \u2014 Includes the desired variables for the dark color scheme."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"theme.custom.scss"})," \u2014 Includes custom styles."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"theme.base.scss"})," \u2014 Contains global styles, css rules that will apply across the app."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"globals.scss"})," \u2014 Introduces scss functionality on the the styles and contains imports to:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"globals.custom.scss"})," \u2014 Global custom scss variables."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"globals.variables.scss"})," \u2014 Global scss variables."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"globals.mixins.scss"})," \u2014 App customised mixins."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"globals.mixins.ionic.scss"})," \u2014 Imported mixins from ionic."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"format-text.scss"})," \u2014 Contains format-text tag styles."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"assets",children:"assets/"}),"\n",(0,i.jsx)(n.p,{children:"This folder contains source files that are not considered app code. This includes things like fonts, images, and json files; but also external libraries that couldn't be installed using npm (for example, h5p and mathjax)."}),"\n",(0,i.jsxs)(n.p,{children:["An exception to this rule is ",(0,i.jsx)(n.code,{children:"js/iframe-treat-link.js"}),", which is a file that can be considered app code but it is injected directly into iframes without a compilation step."]}),"\n",(0,i.jsx)(n.h3,{id:"file-names",children:"File names"}),"\n",(0,i.jsxs)(n.p,{children:["As a rule of thumb, TypeScript files should be named after the class or interface they export. Given that ",(0,i.jsx)(n.a,{href:"https://stackoverflow.com/questions/45962317/why-isnt-export-default-recommended-in-angular",children:"it's discouraged to use default exports in Angular applications"}),", it is not obvious what that is for each file. But in most cases it should be fairly easy to see. In situations where there isn't a single relevant export, like a file exporting multiple functions, you should use a name that properly reflects the nature of this grouping."]}),"\n",(0,i.jsxs)(n.p,{children:["File names should use ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Letter_case#Kebab_case",children:"kebab case"})," and not include namespaces nor type suffixes. For example, if there is a service declared within ",(0,i.jsx)(n.code,{children:"core/services/"})," called ",(0,i.jsx)(n.code,{children:"CoreFoobarService"}),", its file name should be ",(0,i.jsx)(n.code,{children:"foobar.ts"}),", not ",(0,i.jsx)(n.code,{children:"core-foobar-service.ts"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If a folder contains more than one type of TypeScript file, the type of file should be added as a suffix with a dot. For example, the ",(0,i.jsx)(n.code,{children:"app/"})," folder contains multiple types of classes and that's why the file declaring the root component is named ",(0,i.jsx)(n.code,{children:"app.component.ts"}),". Most components elsewhere don't have the ",(0,i.jsx)(n.em,{children:".component"})," suffix. The exception to this rule are module and test files, which must always use the ",(0,i.jsx)(n.em,{children:".module"})," and ",(0,i.jsx)(n.em,{children:".test"})," suffix respectively."]}),"\n",(0,i.jsx)(n.h3,{id:"language-files",children:"Language files"}),"\n",(0,i.jsxs)(n.p,{children:["All feature and addon folders can contain a ",(0,i.jsx)(n.code,{children:"lang.json"})," file, as well as the ",(0,i.jsx)(n.code,{children:"core/"})," folder. The JSON file contains all translatable string keys with the current english text. During compilation, those files will be merged into one single file on ",(0,i.jsx)(n.code,{children:"assets/lang/en.json"})," that will contain the cooked string keys (every key of those files will be prepended with the module prefix)."]}),"\n",(0,i.jsxs)(n.p,{children:["An automatic process will create the rest of the language files on the ",(0,i.jsx)(n.code,{children:"assets/lang/"})," folder based on the Moodle translation platform: ",(0,i.jsx)(n.a,{href:"https://lang.moodle.org/",children:"AMOS"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["In order to match existing Moodle language strings with the app strings the app contains a file on the scripts folder called ",(0,i.jsx)(n.code,{children:"langindex.json"}),". This file contains an indexed array with the cooked string keys of the app, the value of every item is the module (file name) where to find the string in AMOS. If the value contains a slash '/' the text before the slash will correspond to the module (file name) and the text after will correspond to the string key on that file. If it does not contain a slash, the string key will be the last part of the cooked string key (splitting using dots .)."]}),"\n",(0,i.jsx)(n.h3,{id:"constants-files",children:"Constants files"}),"\n",(0,i.jsxs)(n.p,{children:["All exported constants should be declared within a ",(0,i.jsx)(n.code,{children:"constants.ts"}),' file. The term "constant" in TypeScript can be somewhat misleading, given that it is often used with the ',(0,i.jsx)(n.code,{children:"const"}),' keyword. What we mean with "constants" is simple read-only values. Most of the time, these will be primitive values (string, number, boolean, etc.) or simple objects.']}),"\n",(0,i.jsxs)(n.p,{children:["This may seem cumbersome at first, but it's very important in order to optimize ",(0,i.jsx)(n.a,{href:"https://webpack.js.org/guides/code-splitting/",children:"Code Splitting"}),". Which can seriously impact performance. Given the size of the codebase, including a file in a bundle that doesn't need it can result in a cascade effect that bloats chunk sizes significantly. And constants are usually used outside of a module (for example, using route segments or unique identifiers)."]}),"\n",(0,i.jsx)(n.p,{children:"Additionally, because it's very likely that the content of these files ends up in the initial bundle of the application, they should seldom import anything (possibly with the exception of other constants)."}),"\n",(0,i.jsx)(n.h3,{id:"test-files",children:"Test files"}),"\n",(0,i.jsxs)(n.p,{children:["Tests are found anywhere inside the ",(0,i.jsx)(n.code,{children:"src/"})," folder, and they will be run as long as they end with ",(0,i.jsx)(n.em,{children:".test.ts"}),". As a general rule, they are placed in a folder next to the module responsible for the code being tested. And they mirror the folder structure."]}),"\n",(0,i.jsx)(n.p,{children:"Here are some examples:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The utils text service declared in ",(0,i.jsx)(n.code,{children:"core/services/utils/text.ts"})," is tested in ",(0,i.jsx)(n.code,{children:"core/services/tests/utils/text.test.ts"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The credentials page declared in ",(0,i.jsx)(n.code,{children:"core/features/login/pages/credentials/credentials.ts"})," is tested in ",(0,i.jsx)(n.code,{children:"core/features/login/tests/credentials.test.ts"}),". The test file can be directly under ",(0,i.jsx)(n.code,{children:"tests/"})," (instead of ",(0,i.jsx)(n.code,{children:"tests/pages/credentials/"}),") because the page component is the only file that will be tested for this folder. So it would be unnecessary to have a folder with a single file."]}),"\n",(0,i.jsxs)(n.li,{children:["The root app component declared in ",(0,i.jsx)(n.code,{children:"app/app.component.ts"})," is tested in ",(0,i.jsx)(n.code,{children:"app/app.component.test.ts"}),". The test file can live alongside the component because this module doesn't have any nested folders."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In addition to unit test files, there is also a folder at ",(0,i.jsx)(n.code,{children:"testing/"})," with setup and file utilities shared among all tests."]}),"\n",(0,i.jsxs)(n.p,{children:["Learn more about unit tests in the ",(0,i.jsx)(n.a,{href:"#testing",children:"Testing"})," section."]}),"\n",(0,i.jsx)(n.h2,{id:"routing",children:"Routing"}),"\n",(0,i.jsxs)(n.p,{children:["All core features and addons can define their own routes, and we can do that in their main module. However, those are loaded when the application starts up, and that won't be desirable in most cases. We can use ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/lazy-loading-ngmodules",children:"lazy loading"})," to defer loading routes until they are necessary. To encapsulate lazy functionality, we can define a ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/module-types#routed",children:"Routed Module"})," named ",(0,i.jsx)(n.code,{children:"{feature-name}LazyModule"}),". For example, the ",(0,i.jsx)(n.em,{children:"login"})," core feature defines both a ",(0,i.jsx)(n.code,{children:"CoreLoginModule"})," (for routes that are loaded when the application starts up) and a ",(0,i.jsx)(n.code,{children:"CoreLoginLazyModule"})," (for routes that are loaded only when necessary)."]}),"\n",(0,i.jsx)(n.h3,{id:"dynamic-routes",children:"Dynamic Routes"}),"\n",(0,i.jsxs)(n.p,{children:["With the ",(0,i.jsx)(n.a,{href:"#folders-structure",children:"folders structure"})," we're using, it is often the case where different core features or addons need to define routes depending on each other. For example, the ",(0,i.jsx)(n.em,{children:"mainmenu"})," feature defines the layout and routes for the tabs that are always present at the bottom of the UI. But the home tab is defined in the ",(0,i.jsx)(n.em,{children:"home"})," feature. In this scenario, it would be possible to just import the pages from the ",(0,i.jsx)(n.em,{children:"home"})," module within the ",(0,i.jsx)(n.em,{children:"mainmenu"}),", since both are core features and are allowed to know each other. But that approach can become messy, and what happens if an addon also needs to define a tab (like ",(0,i.jsx)(n.em,{children:"privatefiles"}),")?"]}),"\n",(0,i.jsxs)(n.p,{children:["As described in the ",(0,i.jsx)(n.a,{href:"#addons",children:"addons/ folder documentation"}),", the answer to this situation is using the dependency inversion principle. Instead of the ",(0,i.jsx)(n.em,{children:"mainmenu"})," depending on anything rendering a tab (",(0,i.jsx)(n.em,{children:"home"}),", ",(0,i.jsx)(n.em,{children:"privatefiles"}),", etc.), we can make those depend on ",(0,i.jsx)(n.em,{children:"mainmenu"}),". And we can do that using Angular's container."]}),"\n",(0,i.jsxs)(n.p,{children:["In order to allow injecting routes from other modules, we create a separated ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/module-types#routing-ngmodules",children:"Routing Module"}),". This is the only situation where we'll have a dedicated module for routing. Any routes that are not meant to be injected can be defined directly on their main or lazy module."]}),"\n",(0,i.jsxs)(n.p,{children:["It is often the case that modules using injected routes use a ",(0,i.jsx)(n.a,{href:"https://angular.io/api/router/RouterOutlet",children:"RouterOutlet"}),". For that reason, injected routes can be defined either as children or siblings of the main route. The difference between those is that a child will be rendered within the outlet, whilst a sibling will replace the entire page. In order to make this distinction, routing modules accept either an array of routes to use as siblings or an object indicating both types of routes."]}),"\n",(0,i.jsxs)(n.p,{children:["Finally, since these routes are defined dynamically, they cannot be imported statically when defining parent routes. They will need to be encapsulated on a builder function, taking an ",(0,i.jsx)(n.code,{children:"injector"})," as an argument to resolve all the injected routes. You can see an example of this in the ",(0,i.jsx)(n.code,{children:"buildTabMainRoutes"}),", and how it's used across the app."]}),"\n",(0,i.jsx)(n.h3,{id:"split-view-routes",children:"Split View Routes"}),"\n",(0,i.jsx)(n.p,{children:"Some pages in the app use a split-view pattern that consists of a navigation menu on the left, and the main content in the right (in LTR interfaces). It is typically used to display a list of items in the menu, and display the contents of the selected item in the content. For example, showing a list of settings on the left with their content on the right."}),"\n",(0,i.jsxs)(n.p,{children:["This pattern is used in large screens (such as tablets), and logically is made up of two pages: one used for the menu and one for the content. The one with the menu defines an outlet for the content page, and in smaller devices (such as mobile phones), the outlet is hidden and navigating to items will override the entire page instead of populating the outlet. This is achieved by the styles and markup of the ",(0,i.jsx)(n.code,{children:"<core-split-view>"})," component."]}),"\n",(0,i.jsxs)(n.p,{children:["In order for the different behaviour to take place, routes are defined twice. Once where the content is a children of the menu, and again where the content is a sibling of the menu. These two definitions would clash in normal situations, but they are defined with a conditional that toggles them depending on the active breakpoint. You can find an example looking at the route definitions in the ",(0,i.jsx)(n.code,{children:"CoreSettingsLazyModule"}),", which correspond with the routes that you can visit from the Main Menu > More > App Settings."]}),"\n",(0,i.jsxs)(n.p,{children:["The navigation between these routes is often encapsulated within a ",(0,i.jsx)(n.code,{children:"CoreListItemsManager"})," instance, that takes care of discerning the current active item and updating the route when selected items change. This manager will obtain the items from a ",(0,i.jsx)(n.code,{children:"CoreRoutedItemsManagerSource"}),", which is necessary to enable ",(0,i.jsx)(n.a,{href:"#navigating-using-swipe-gestures",children:"swipe navigation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"navigating-between-routes",children:"Navigating between routes"}),"\n",(0,i.jsxs)(n.p,{children:["In order to navigate between routes, you should use the ",(0,i.jsx)(n.code,{children:"CoreNavigator"})," service. It works using Angular's router under the hood, and it takes care of all the routing specific to our application."]}),"\n",(0,i.jsxs)(n.p,{children:["Most of the time, you'll probably want to use the ",(0,i.jsx)(n.code,{children:"navigateToSitePath"})," method, because it will take into account the current main menu tab and navigate accordingly. If the call needs to navigate to another site, it'll also take care of all the login workflow."]}),"\n",(0,i.jsx)(n.p,{children:"If you are navigating to a specific route that is not affected by the current site nor the main menu tab, you can use the navigate method directly. This method can also be useful if you want to navigate relative to the current route, for example doing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"CoreNavigator.navigate('../');\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Other than navigation, this service also contains some helpers that are not available in Angular out of the box. For example, the ",(0,i.jsx)(n.code,{children:"getRouteParam"})," will get values from multiple sources such as query parameters or route parameters, and it also supports reading non-primitive values."]}),"\n",(0,i.jsxs)(n.p,{children:["Make sure to ",(0,i.jsx)(n.a,{href:"https://github.com/moodlehq/moodleapp/blob/main/src/core/services/navigator.ts",children:"check out the full api"})," to learn more about the ",(0,i.jsx)(n.code,{children:"CoreNavigator"})," service."]}),"\n",(0,i.jsx)(n.h3,{id:"navigating-using-swipe-gestures",children:"Navigating using swipe gestures"}),"\n",(0,i.jsxs)(n.p,{children:["Most pages that use a split-view in tablets can be navigated using swipe gestures in mobile devices. The navigation is often encapsulated within a ",(0,i.jsx)(n.code,{children:"CoreSwipeNavigationItemsManager"})," instance."]}),"\n",(0,i.jsxs)(n.p,{children:["As mentioned in the ",(0,i.jsx)(n.a,{href:"#split-view-routes",children:"split-view section"}),", the items used by the manager are obtained from a ",(0,i.jsx)(n.code,{children:"CoreRoutedItemsManagerSource"}),". This source will be reused between menu and content pages in mobile as well, so that swipe navigation respects any filters that have been applied in the menu page. In order to make sure that the same instance is reused, instead of creating a new one, these can be instantiated using the ",(0,i.jsx)(n.code,{children:"CoreRoutedItemsManagerSourcesTracker.getOrCreateSource()"})," method. It will reuse instances that are still active, and when passed to managers the references will be cleared up when the managers are destroyed."]}),"\n",(0,i.jsxs)(n.p,{children:["You can find an example of this pattern in ",(0,i.jsx)(n.code,{children:"CoreUserParticipantsPage"}),", where participants can be filtered and the swipe navigation will respect the filtered results."]}),"\n",(0,i.jsx)(n.h2,{id:"singletons",children:"Singletons"}),"\n",(0,i.jsxs)(n.p,{children:["The application relies heavily on the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Singleton_pattern",children:"Singleton design pattern"}),", and there are two types of singletons used throughout the application: Pure singletons and Service singletons."]}),"\n",(0,i.jsx)(n.h3,{id:"pure-singletons",children:"Pure Singletons"}),"\n",(0,i.jsx)(n.p,{children:'Pure singletons, or just "singletons", are plain Typescript classes whose functionality does not depend on the lifecycle of the application. These normally contain helper or utility methods that enhance existing apis or encapsulate reusable functionality.'}),"\n",(0,i.jsx)(n.p,{children:"Their implementations usually consist of a collection of static methods (so technically they are not singletons, but in practice this is easier to work with)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export class CoreArray {\n\n    static contains<T>(items: T[], item: T): boolean {\n        return items.indexOf(item) !== -1;\n    }\n\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"service-singletons",children:"Service Singletons"}),"\n",(0,i.jsxs)(n.p,{children:["Service singletons are instances resolved from the ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/hierarchical-dependency-injection",children:"root application injector"}),". In contrast with pure singletons, these are defined as Angular services. In particular, these should be ",(0,i.jsx)(n.a,{href:"https://angular.io/guide/singleton-services",children:"singleton services"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The motivation behind using this pattern to access service instances is improving the development experience (easier auto-imports) and delaying the instantiation of services until they are really needed."}),"\n",(0,i.jsx)(n.p,{children:"For example, service A may rely on service B in one method. Using Angular's dependency management you would declare service B in the constructor of service A. In this situation, service B would be instantiated whenever service A is instantiated, regardless of the method that uses it being called or not. Given the size of the codebase, this can have a cascading effect detrimental to the performance of the application. With the Service Singleton pattern, service B would only be instantiated when the method that uses it in service A is called."}),"\n",(0,i.jsxs)(n.p,{children:["To adopt this pattern, the only additional step in the service definition is to use the ",(0,i.jsx)(n.code,{children:"makeSingleton"})," method (make sure to declare it as provided in root):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable({ providedIn: 'root' })\nexport class CoreUserService {\n\n    // ...\n\n}\n\nexport const CoreUser = makeSingleton(CoreUserService);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This method will create a proxy that will relay all the method calls to the service singleton instance. This proxy can be used like you would use an injected instance of the service. When any method is called, the underlying service will be initialised lazily. If you need to access the actual instance, you can do it via the ",(0,i.jsx)(n.code,{children:"instance"})," property."]}),"\n",(0,i.jsx)(n.p,{children:"Since they are normal Angular services under the hood, they can be overridden in other modules. But keep in mind that because they are singletons, they will be replaced everywhere and not just in the module where they are being defined."}),"\n",(0,i.jsx)(n.p,{children:"Here's one example of this overriding a core Angular service:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export class MyHttpClient extends HttpClient {}\n\nexport const Http = makeSingleton(HttpClient);\n\n@NgModule({\n    providers: [\n        { provide: HttpClient, useClass: MyHttpClient },\n    ],\n})\nexport class MyModule {}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This pattern can be used mostly everywhere, because the underlying system is initialised before the app initialisation begins."}),"\n",(0,i.jsxs)(n.p,{children:["The exception to this rule is within service constructors, given that we don't have absolute control over when Angular will create service instances. For this same reason, code intended to run on application startup must be placed on an ",(0,i.jsx)(n.a,{href:"#coreinitializers",children:"initializer"}),". And anything else within a service should be initialised lazily, instead of using the constructor (a general good practice in programming is that constructors shouldn't have side-effects)."]}),"\n",(0,i.jsx)(n.p,{children:"In the rare cases where a constructor really needs a dependency, it's always possible to fall back to Angular's built-in pattern of declaring dependencies in the constructor."}),"\n",(0,i.jsx)(n.p,{children:"All the nomenclature can be a bit confusing, so let's do a recap:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Singleton Service: An Angular service that will be instantiated at most once in the entire lifecycle of the application."}),"\n",(0,i.jsx)(n.li,{children:"Service Singleton: An instance of a Singleton Service."}),"\n",(0,i.jsx)(n.li,{children:"Singleton Proxy: An object that relays method calls to a Service Singleton instance."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"database",children:"Database"}),"\n",(0,i.jsxs)(n.p,{children:["Most of the persistent data in the application is stored in SQLite databases. In particular, there is one database for global app configuration, and one for each site. Reading and writing data is encapsulated in the ",(0,i.jsx)(n.code,{children:"CoreDatabaseTable"})," class. Each table can be configured to use one of the following caching strategies:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Eager Caching: When the table is initialised, it will query all the records and store them in memory. This improves performance for data that is read very often, because reads will happen in-memory without touching the database. But it shouldn't be used for tables with a lot of records, to reduce memory consumption."}),"\n",(0,i.jsx)(n.li,{children:"Lazy Caching: Lazy caching works similar to eager caching, but instead of querying all the records upfront it'll remember records after reading them for the first time. This strategy is more appropriate for tables that are read often but have too many records to cache completely in memory."}),"\n",(0,i.jsx)(n.li,{children:"No Caching: Finally, for tables that are written more often than they are read, it is possible to disable caching altogether."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Something else important to note is that not all these tables are instantiated when the application is initialized, so for example even though a table may have Eager loading; it could be itself initialized lazily."}),"\n",(0,i.jsx)(n.h3,{id:"schema-migrations",children:"Schema migrations"}),"\n",(0,i.jsxs)(n.p,{children:["Table schemas are declared using ",(0,i.jsx)(n.code,{children:"CoreAppSchema"}),", ",(0,i.jsx)(n.code,{children:"CoreSiteSchema"}),", and ",(0,i.jsx)(n.code,{children:"SQLiteDBTableSchema"})," interfaces; and invoked using ",(0,i.jsx)(n.code,{children:"CoreApp.createTablesFromSchema()"})," and ",(0,i.jsx)(n.code,{children:"CoreSitesProvider.applySiteSchemas()"}),". In the case of site tables, these can be registered with the ",(0,i.jsx)(n.code,{children:"CORE_SITE_SCHEMAS"})," injection token and they'll be invoked automatically when a new site is created."]}),"\n",(0,i.jsxs)(n.p,{children:["In order to make some changes in existing schemas, it'll be necessary to change the ",(0,i.jsx)(n.code,{children:"version"})," number and implement the ",(0,i.jsx)(n.code,{children:"migrate"})," method to perform any operations necessary during the migration."]}),"\n",(0,i.jsx)(n.h3,{id:"legacy",children:"Legacy"}),"\n",(0,i.jsxs)(n.p,{children:["Ideally, all interactions with the database would go through a ",(0,i.jsx)(n.code,{children:"CoreDatabaseTable"})," instance. However, there is still some code using the previous approach through the ",(0,i.jsx)(n.code,{children:"SQLiteDB"})," class. This should be avoided for new code, and eventually migrated to use the new approach to take advantage of caching."]}),"\n",(0,i.jsx)(n.h2,{id:"application-lifecycle",children:"Application Lifecycle"}),"\n",(0,i.jsxs)(n.p,{children:["When the application is launched, the contents of ",(0,i.jsx)(n.a,{href:"#indexhtml",children:"index.html"})," are rendered on screen. This file is intentionally concise because all the flare is added by JavaScript, and the splash screen will be covering the application UI until it has fully started. If you are developing in the browser, this will be a blank screen for you given that the splash screen is not available on the web. We are not targeting browsers in production, so it's acceptable to have this behaviour during development."]}),"\n",(0,i.jsxs)(n.p,{children:["Before the UI is rendered, the startup process will take place. First, Angular will instantiate ",(0,i.jsx)(n.code,{children:"AppModule"})," and all the imported modules (features, addons, etc.), and then it will execute the initializers (this includes all the initializers, not only the ones declared under ",(0,i.jsx)(n.a,{href:"#coreinitializers",children:"core/initializers/"}),"). In our application, we have overridden ",(0,i.jsx)(n.a,{href:"https://angular.io/api/core/ApplicationInitStatus",children:"Angular's initialisation service"})," to get a hold of the root injector so that we can safely use the ",(0,i.jsx)(n.a,{href:"#service-singletons",children:"Service Singletons"})," pattern within initializers. However, we should avoid this pattern within constructors, because those can be called during the instantiation phase."]}),"\n",(0,i.jsx)(n.p,{children:"Once the application has finished starting up, the router will resolve the active route and the corresponding page component will be rendered. At this point, the splash screen will be hidden and the app is interactive."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"A summary of the Application Lifecycle",src:t(66308).A+"",width:"445",height:"341"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-1",children:"Testing"}),"\n",(0,i.jsx)(n.p,{children:"There are two types of tests in the mobile app."}),"\n",(0,i.jsx)(n.h3,{id:"unit",children:"Unit"}),"\n",(0,i.jsxs)(n.p,{children:["Unit tests are written in JavaScript using ",(0,i.jsx)(n.a,{href:"https://jestjs.io/",children:"jest"}),". If you want to create a new one, jest is already configured and you only need to create a file ending with ",(0,i.jsx)(n.em,{children:".test.ts"})," within the project. If you're going to do so, remember to follow the ",(0,i.jsx)(n.a,{href:"#test-files",children:"file location conventions"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["You can run the entire test suite using the npm test command. If you are using VSCode, you can also use the debugger to ",(0,i.jsx)(n.a,{href:"https://github.com/moodlehq/moodleapp/blob/main/.vscode/launch.json",children:"run preconfigured test tasks"})," in the current file or the entire project (using F5 with the default keybindings). This will allow you to use breakpoints and other advanced debugging tools."]}),"\n",(0,i.jsxs)(n.p,{children:["You can write standard jest tests for the most part, but something to keep in mind is that the codebase relies heavily on ",(0,i.jsx)(n.a,{href:"#service-singletons",children:"Service Singletons"}),". So you will need to mock any instances that are used in the code you're testing."]}),"\n",(0,i.jsxs)(n.p,{children:["You can learn more about this in the ",(0,i.jsx)(n.a,{href:"/moodledevdocs/general/app/development/testing/unit-testing",children:"Unit testing for the Moodle App"})," page."]}),"\n",(0,i.jsx)(n.h3,{id:"acceptance",children:"Acceptance"}),"\n",(0,i.jsxs)(n.p,{children:["Acceptance tests are written in ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Cucumber_(software)#Gherkin_language",children:"Gherkin"})," using ",(0,i.jsx)(n.a,{href:"/moodledevdocs/general/app/development/testing/acceptance-testing",children:"Behat"}),". These are run against the full application with a real Moodle site, so they are more heavy-handed and will take longer to run. But they are also much more realistic than unit tests."]}),"\n",(0,i.jsxs)(n.p,{children:["If you are using ",(0,i.jsx)(n.a,{href:"https://github.com/moodlehq/moodle-docker",children:"moodle-docker"}),", you can configure it to ",(0,i.jsx)(n.a,{href:"https://github.com/moodlehq/moodle-docker#use-containers-for-running-behat-tests-for-the-mobile-app",children:"run the tests from your local copy of the application"}),". Keep in mind that doing this will run the app on a docker image, and expose the dev server to your machine. So you shouldn't be running ",(0,i.jsx)(n.code,{children:"npm start"})," or any other commands launching a dev server while docker is running, or you'll have two instances running and that can cause some problems."]}),"\n",(0,i.jsxs)(n.p,{children:["In order to run your Behat tests, they need to be installed in the Moodle site. You can automate this process by running the ",(0,i.jsx)(n.code,{children:"npx gulp behat"})," command in the app folder, which will create a local plugin containing your application tests. This uses the environment variables from moodle-docker, if you're not using it you can also configure this by setting the ",(0,i.jsx)(n.code,{children:"MOODLE_APP_BEHAT_PLUGIN_PATH"})," variable. If you want to keep them up to date every time you change the test files, you can run ",(0,i.jsx)(n.code,{children:"npx gulp watch-behat"})," (this is already done when developing locally, but if you're serving the app with moodle-docker you'll need to run this from your local machine)."]}),"\n",(0,i.jsx)(n.p,{children:"You can write standard Behat tests for the most part, but there are some steps specific for the Moodle App that you should use instead of the ones for the Moodle LMS."}),"\n",(0,i.jsxs)(n.p,{children:["You can learn more about this in the ",(0,i.jsx)(n.a,{href:"/moodledevdocs/general/app/development/testing/acceptance-testing",children:"Acceptance testing for the Moodle App"})," page."]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/moodledevdocs/general/app/development/accessibility",children:"Moodle App Accessibility"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/moodledevdocs/general/app/development/link-handling/app-links",children:"Moodle App Link Handling"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.moodle.org/en/Moodle_App_Translation",children:"Moodle App Translation"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},66308:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/application_lifecycle-8d4b8ea7c6b9bd777d26aa93d74c3598.jpg"}}]);