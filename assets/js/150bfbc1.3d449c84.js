"use strict";(self.webpackChunkdevdocs=self.webpackChunkdevdocs||[]).push([[21683],{59999:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var s=i(74848),a=i(28453),n=i(78924);const o={title:"Cache API",tags:["API","Subsystem","MUC"]},c=void 0,r={id:"apis/subsystems/muc/index",title:"Cache API",description:"This document provides an in-depth overview of the Cache API, also known as MUC (Moodle Universal Cache), a fundamental caching system within Moodle.",source:"@site/docs/apis/subsystems/muc/index.md",sourceDirName:"apis/subsystems/muc",slug:"/apis/subsystems/muc/",permalink:"/moodledevdocs/docs/4.4/apis/subsystems/muc/",draft:!1,unlisted:!1,editUrl:"https://github.com/moodle/devdocs/edit/main/docs/apis/subsystems/muc/index.md",tags:[{label:"API",permalink:"/moodledevdocs/docs/4.4/tags/api"},{label:"Subsystem",permalink:"/moodledevdocs/docs/4.4/tags/subsystem"},{label:"MUC",permalink:"/moodledevdocs/docs/4.4/tags/muc"}],version:"current",lastUpdatedBy:"Tabish Naqvi",lastUpdatedAt:1701418175e3,frontMatter:{title:"Cache API",tags:["API","Subsystem","MUC"]},sidebar:"docs",previous:{title:"Groups API",permalink:"/moodledevdocs/docs/4.4/apis/subsystems/group/"},next:{title:"Output API",permalink:"/moodledevdocs/docs/4.4/apis/subsystems/output/"}},h={},l=[{value:"Basic usage",id:"basic-usage",level:2},{value:"Creating a definition",id:"creating-a-definition",level:3},{value:"Getting a cache object",id:"getting-a-cache-object",level:3},{value:"Using your cache object",id:"using-your-cache-object",level:3},{value:"Ad-hoc Caches",id:"ad-hoc-caches",level:2},{value:"The definition",id:"the-definition",level:2},{value:"Setting requirements",id:"setting-requirements",level:3},{value:"Cache modifiers",id:"cache-modifiers",level:3},{value:"Overriding a cache loader",id:"overriding-a-cache-loader",level:3},{value:"Specifying a data source",id:"specifying-a-data-source",level:3},{value:"Misc settings",id:"misc-settings",level:3},{value:"Localized stores for distributed high performance caching",id:"localized-stores-for-distributed-high-performance-caching",level:2},{value:"When should you localize?",id:"when-should-you-localize",level:3},{value:"Revision numbers as key suffix",id:"revision-numbers-as-key-suffix",level:3},{value:"Revision numbers as value suffix instead of key suffix",id:"revision-numbers-as-value-suffix-instead-of-key-suffix",level:3},{value:"Using time as a key suffix",id:"using-time-as-a-key-suffix",level:3},{value:"Content hashes as keys",id:"content-hashes-as-keys",level:3},{value:"Primary and Final caches",id:"primary-and-final-caches",level:3},{value:"Beware fast churning keys",id:"beware-fast-churning-keys",level:3},{value:"Time-To-Live for distributed caches",id:"time-to-live-for-distributed-caches",level:3},{value:"Miscellaneous",id:"miscellaneous",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.A,{frontMatter:o,metadata:r}),"\n",(0,s.jsx)(t.p,{children:"This document provides an in-depth overview of the Cache API, also known as MUC (Moodle Universal Cache), a fundamental caching system within Moodle."}),"\n",(0,s.jsxs)(t.p,{children:["This document uses a hypothetical module plugin named ",(0,s.jsx)(t.code,{children:"myplugin"})," as the focal point."]}),"\n",(0,s.jsxs)(t.p,{children:["There is also a ",(0,s.jsx)(t.a,{href:"https://docs.moodle.org/dev/Cache_API_-_Quick_reference",children:"Cache API - Quick reference"})," if you would rather read that."]}),"\n",(0,s.jsx)(t.h2,{id:"basic-usage",children:"Basic usage"}),"\n",(0,s.jsx)(t.p,{children:"Getting started with the Cache API is exceptionally straightforward. It's designed for quick and easy usage, emphasizing self-containment.\nAll you need to do is add a definition for your cache and you are ready to start working with the Cache API."}),"\n",(0,s.jsx)(t.h3,{id:"creating-a-definition",children:"Creating a definition"}),"\n",(0,s.jsxs)(t.p,{children:["Cache definitions exist within the ",(0,s.jsx)(t.code,{children:"db/caches.php"})," file for a component/plugin."]}),"\n",(0,s.jsxs)(t.p,{children:["In the case of core that is the ",(0,s.jsx)(t.code,{children:"lib/db/caches.php"})," file, in the case of a module that would be ",(0,s.jsx)(t.code,{children:"mod/myplugin/db/caches.php"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"The definition is used API in order to understand a little about the cache and what it is being used for, it also allows the administrator to set things up especially for the definition if they want.\nFrom a development point of view the definition allows you to tell the API about your cache, what it requires, and any (if any) advanced features you want it to have."}),"\n",(0,s.jsx)(t.p,{children:"The following shows a basic definition containing just the bare minimum:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",metastring:'title="mod/myplugin/db/caches.php"',children:"$definitions = [\n    'somedata' => [\n        'mode' => cache_store::MODE_APPLICATION,\n    ]\n];\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This informs the API that the ",(0,s.jsx)(t.code,{children:"myplugin"})," module has a cache called ",(0,s.jsx)(t.code,{children:"somedata"})," and that it is an application (globally shared) cache."]}),"\n",(0,s.jsxs)(t.p,{children:["When creating a definition that's the bare minimum, to provide an area (",(0,s.jsx)(t.code,{children:"somedata"}),") and declare the type of the cache application, session, or request."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"An application cache is a shared cache, all users can access it."}),"\n",(0,s.jsx)(t.li,{children:"Session caches are scoped to a single users session, but may not actually be stored in the session."}),"\n",(0,s.jsx)(t.li,{children:"Request caches you can think of as static caches, only available to the user owning the request, and only alive until the end of the request."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["There are of course many more options available that allow you to really take the cache by the reigns, you can read about some of the important ones further on, or skip ahead to ",(0,s.jsx)(t.a,{href:"#the-definition",children:"the definition"})," section which details the available options in full."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["For each definition, a language string with the name ",(0,s.jsx)(t.code,{children:"cachedef_"})," followed by the name of the definition is expected."]})}),"\n",(0,s.jsx)(t.p,{children:"Using the example above you would have to define:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",metastring:'title="mod/myplugin/lang/en/mod_myplugin.php"',children:"$string['cachedef_somedata'] = 'This is the description of the cache somedata';\n"})}),"\n",(0,s.jsx)(t.h3,{id:"getting-a-cache-object",children:"Getting a cache object"}),"\n",(0,s.jsx)(t.p,{children:"Once your definition has been created you should bump the version number so that Moodle upgrades and processes the definitions file at which point your definition will be useable."}),"\n",(0,s.jsx)(t.p,{children:"Now within code you can get a cache object corresponding to the definition created earlier."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:"$cache = cache::make('mod_myplugin', 'somedata');\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"cache::make()"})," method is a factory method, it will create a cache object to allow you to work with your cache. The cache object will be one of several classes chosen by the API based upon what your definition contains. All of these classes will extend the base cache class, and in nearly all cases you will get one of ",(0,s.jsx)(t.code,{children:"cache_application"}),", ",(0,s.jsx)(t.code,{children:"cache_session"}),", or ",(0,s.jsx)(t.code,{children:"cache_request"})," depending upon the mode you selected."]}),"\n",(0,s.jsx)(t.h3,{id:"using-your-cache-object",children:"Using your cache object"}),"\n",(0,s.jsxs)(t.p,{children:["Once you have a cache object (will extend the cache class and implements ",(0,s.jsx)(t.code,{children:"cache_loader"}),") you are ready to start interacting with the cache."]}),"\n",(0,s.jsx)(t.p,{children:"There are three basic basic operations: get, set, and delete."}),"\n",(0,s.jsx)(t.p,{children:"The first is to send something to the cache."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:"$result = $cache->set('key', 'value');\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Easy enough. The key must be an ",(0,s.jsx)(t.code,{children:"int"})," or a ",(0,s.jsx)(t.code,{children:"string"}),". The value can be absolutely anything your want that is ",(0,s.jsx)(t.a,{href:"https://www.php.net/manual/en/function.serialize.php",children:"serializable"}),".\nThe result is true if the operation was a success, false otherwise."]}),"\n",(0,s.jsx)(t.p,{children:"The second is to fetch something from the cache."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:"$data = $cache->get('key');\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"$data"})," will either be whatever was being stored in the cache, or false if the cache could not find the key."]}),"\n",(0,s.jsx)(t.p,{children:"The third and final operation is delete."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:"$result = $cache->delete('key');\n"})}),"\n",(0,s.jsx)(t.p,{children:"Again just like set the result will either be true if the operation was a success, or false otherwise."}),"\n",(0,s.jsxs)(t.p,{children:["You can also set, get, and delete multiple ",(0,s.jsx)(t.code,{children:"key => value"})," pairs in a single transaction."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:"$result = $cache->set_many([\n    'key1' => 'data1',\n    'key3' => 'data3'\n]);\n// $result will be the number of pairs sucessfully set.\n\n$result = $cache->get_many(['key1', 'key2', 'key3']);\nprint_r($result);\n// Will print the following:\n// array(\n//     'key1' => 'data1',\n//     'key2' => false,\n//     'key3' => 'data3'\n// )\n\n$result = $cache->delete_many(['key1', 'key3']);\n// $result will be the number of records sucessfully deleted.\n"})}),"\n",(0,s.jsxs)(t.p,{children:["That covers the basic operation of the Cache API.",(0,s.jsx)("br",{}),"\nIn many situations there is not going to be any more to it than that."]}),"\n",(0,s.jsx)(t.h2,{id:"ad-hoc-caches",children:"Ad-hoc Caches"}),"\n",(0,s.jsxs)(t.p,{children:["This is the alternative method of using the cache API.",(0,s.jsx)("br",{}),"\nIt involves creating a cache using just the required params at the time that it is required. It doesn't require that a definition exists making it quicker and easier to use, however it can only use the default settings and is only recommended for insignificant caches (rarely used during operation, never to be mapped or customised, only existing in a single place in code)."]}),"\n",(0,s.jsx)(t.p,{children:"Once a cache object has been retrieved it operates exactly as the same as a cache that has been created for a definition."}),"\n",(0,s.jsx)(t.p,{children:"To create an ad-hoc cache you would use the following:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:"$cache = cache::make_from_params(cache_store::MODE_APPLICATION, 'mod_myplugin', 'mycache');\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"Don't be lazy, if you don't have a good reason to use an ad-hoc cache you should be spending an extra 5 minutes creating a definition."})}),"\n",(0,s.jsx)(t.h2,{id:"the-definition",children:"The definition"}),"\n",(0,s.jsx)(t.p,{children:"The above section illustrated how to create a basic definition, specifying just the area name (the key) and the mode for the definition. Those being the two required properties for a definition."}),"\n",(0,s.jsx)(t.p,{children:"There are many other options that will let you make the most of the Cache API and will undoubtedly be required when implementing and converting cache solutions to the Cache API."}),"\n",(0,s.jsx)(t.p,{children:"The following details the options available to a definition and their defaults if not applied:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:"$definitions = [\n    // The name of the cache area is the key. The component/plugin will be picked up from the file location.\n    'area' => [\n        'mode' => cache_store::MODE_*,\n        'simplekeys' => false,\n        'simpledata' => false,\n        'requireidentifiers' => ['ident1', 'ident2'],\n        'requiredataguarantee' => false,\n        'requiremultipleidentifiers' => false,\n        'requirelockingread' => false,\n        'requirelockingwrite' => false,\n        'requirelockingbeforewrite' => false,\n        'maxsize' => null,\n        'overrideclass' => null,\n        'overrideclassfile' => null,\n        'datasource' => null,\n        'datasourcefile' => null,\n        'staticacceleration' => false,\n        'staticaccelerationsize' => null,\n        'ttl' => 0,\n        'mappingsonly' => false,\n        'invalidationevents' => ['event1', 'event2'],\n        'canuselocalstore' => false\n        'sharingoptions' => cache_definition::SHARING_DEFAULT,\n        'defaultsharing' => cache_definition::SHARING_DEFAULT,\n    ],\n];\n"})}),"\n",(0,s.jsx)(t.h3,{id:"setting-requirements",children:"Setting requirements"}),"\n",(0,s.jsx)(t.p,{children:"The definition can specify several requirements for the cache."}),"\n",(0,s.jsx)(t.p,{children:"This includes identifiers that must be provided when creating the cache object, that the store guarantees data stored in it will remain there until removed, a store that supports multiple identifiers, and finally read/write locking."}),"\n",(0,s.jsx)(t.p,{children:"The options for these are as follows:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"simplekeys"}),": [bool] Set to true if your cache will only use simple keys for its items.",(0,s.jsx)("br",{}),"\nSimple keys consist of digits, underscores and the 26 chars of the english language. ",(0,s.jsx)(t.code,{children:"a-zA-Z0-9_"}),(0,s.jsx)("br",{}),"\nIf true the keys won't be hashed before being passed to the cache store for gets/sets/deletes.",(0,s.jsx)("br",{})," It will be better for performance and possible only because we know the keys are safe."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"simpledata"}),": [bool] If set to true we know that the data is scalar or array of scalar.",(0,s.jsx)("br",{}),"If true, the data values will be stored as they are. Otherwise they will be serialised first."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"requireidentifiers"}),": [array] An array of identifiers that must be provided to the cache when it is created."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"requiredataguarantee"}),": [bool] If set to true then only stores that can guarantee data will remain available once set will be used."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"requiremultipleidentifiers"}),": [bool] If set to true then only stores that support multiple identifiers will be used."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"requirelockingread"}),": [bool] If set to true then a lock will be gained before reading from the cache store. It is recommended not to use this setting unless 100% absolutely positively required."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"requirelockingbeforewrite"}),":[bool] If set to true then a lock must be gained and held during expensive computation such as the generation of modinfo before writing to the cache store by the calling code. This is to prevent cache stampedes. After gaining the lock code must check to ensure the cache hasn't already been updated by another process. This is so far only used by course ",(0,s.jsx)(t.code,{children:"modinfo"})," application caches presently."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"cache-modifiers",children:"Cache modifiers"}),"\n",(0,s.jsx)(t.p,{children:"You are also to modify the way in which the cache is going to operate when working for your definition."}),"\n",(0,s.jsx)(t.p,{children:"By enabling the static option the Cache API will only ever generate a single cache object for your definition on the first request for it, further requests will be returned the original instance"}),"\n",(0,s.jsx)(t.p,{children:"This greatly speeds up the collecting of a cache object."}),"\n",(0,s.jsx)(t.p,{children:"Enabling persistence also enables a static store within the cache object, anything set to the cache, or retrieved from it will be stored in that static array for the life of the request.\nThis makes the persistence options some of the most powerful. If you know you are going to be using you cache over and over again or if you know you will be making lots of requests for the same items then this will provide a great performance boost."}),"\n",(0,s.jsx)(t.p,{children:"Of course the static storage of cache objects and of data is costly in terms of memory and should only be used when actually required, as such it is turned off by default.\nAs well as persistence you can also set a maximum number of items that the cache should store (not a hard limit, its up to each store) and a time to live (ttl) although both are discouraged as efficient design negates the need for both in most situations."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"staticacceleration"}),": [bool] This setting does two important things. First it tells the cache API to only instantiate the cache structure for this definition once, further requests will be given the original instance.",(0,s.jsx)("br",{}),"Second the cache loader will keep an array of the items set and retrieved to the cache during the request.",(0,s.jsx)("br",{}),"This has several advantages including better performance without needing to start passing the cache instance between function calls, the downside is that the cache instance + the items used stay within memory.",(0,s.jsx)("br",{}),"Consider using this setting when you know that there are going to be many calls to the cache for the same information or when you are converting existing code to the cache and need to access the cache within functions but don't want to add it as an argument to the function."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"staticaccelerationsize"}),": [int] This supplements the above setting by limiting the number of items in the caches persistent array of items.",(0,s.jsx)("br",{}),"Tweaking this setting lower will allow you to minimise the memory implications above while hopefully still managing to offset calls to the cache store."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ttl"}),": [int] A time to live for the data (in seconds). It is strongly recommended that you don't make use of this and instead try to create an event driven invalidation system (even if the event is just time expiring, better not to rely on ",(0,s.jsx)(t.code,{children:"ttl"}),").",(0,s.jsx)("br",{}),"Not all cache stores will support this natively and there are undesired performance impacts if the cache store does not."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"maxsize"}),": [int] If set this will be used as the maximum number of entries within the cache store for this definition.",(0,s.jsx)("br",{}),"It's important to note that cache stores don't actually have to acknowledge this setting or maintain it as a hard limit."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"canuselocalstore"}),": [bool] This setting specifies whether the cache can safely be local to each frontend in a cluster which can avoid latency costs to a shared central cache server. The cache needs to be carefully written for this to be safe. It is conceptually similar to using ",(0,s.jsx)(t.code,{children:"$CFG->localcachedir"})," (can be local) vs ",(0,s.jsx)(t.code,{children:"$CFG->cachedir"})," (must be shared). Look at ",(0,s.jsx)(t.code,{children:"purify_html()"})," in ",(0,s.jsx)(t.code,{children:"lib/weblib.php"})," for an example."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"overriding-a-cache-loader",children:"Overriding a cache loader"}),"\n",(0,s.jsx)(t.admonition,{type:"danger",children:(0,s.jsx)(t.p,{children:"This is a super advanced feature and should not be done. Ever. Unless you have a very good reason to do so."})}),"\n",(0,s.jsx)(t.p,{children:"It allows you to create your own cache loader and have it be used instead of the default cache loader class. The cache object you get back from the make operations will be an instance of this class."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"overrideclass"}),": [string] A class to use as the loader for this cache. This is an advanced setting and will allow the developer of the definition to take 100% control of the caching solution.",(0,s.jsx)("br",{}),"Any class used here must inherit the ",(0,s.jsx)(t.code,{children:"cache_loader"})," interface and must extend default cache loader for the mode they are using."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"overrideclassfile"}),": [string] Suplements the above setting indicated the file containing the class to be used. This file is included when required."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"specifying-a-data-source",children:"Specifying a data source"}),"\n",(0,s.jsx)(t.p,{children:"This is a great wee feature, especially if your code is object orientated."}),"\n",(0,s.jsxs)(t.p,{children:["It allows you to specify a class that must inherit the ",(0,s.jsx)(t.code,{children:"cache_data_source"})," object and will be used to load any information requested from the cache that is not already being stored."]}),"\n",(0,s.jsx)(t.p,{children:"When the requested key cannot be found in the cache the data source will be asked to load it. The data source will then return the information to the cache, the cache will store it, and it will then return it to the user as a request of their get request. Essentially no get request should ever fail if you have a data source specified."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"datasource"}),": [string] A class to use as the data loader for this definition.",(0,s.jsx)("br",{}),"Any class used here must inherit the cache_data_source interface."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"datasourcefile"}),": [string] Suplements the above setting indicated the file containing the class to be used. This file is included when required."]}),"\n"]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["In Moodle versions prior to 3.8.6 and 3.9.3, if caching is disabled then ",(0,s.jsx)(t.em,{children:"nothing"})," will be loaded through the data source which is probably not what you expect (rather than the data source being loaded every time but never cached). See also: ",(0,s.jsx)(t.a,{href:"https://tracker.moodle.org/browse/MDL-42012",children:"MDL-42012"})]})}),"\n",(0,s.jsx)(t.h3,{id:"misc-settings",children:"Misc settings"}),"\n",(0,s.jsx)(t.p,{children:"The following are stand along settings that don't fall into any of the above categories."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"invalidationevents"}),": [array] An array of events that should cause this cache to invalidate some or all of the items within it. Note that these are NOT normal moodle events and predates the ",(0,s.jsx)(t.a,{href:"https://docs.moodle.org/dev/Events_API",children:"Events API"}),". Instead these are arbitrary strings which can be used by ",(0,s.jsx)(t.code,{children:"cache_helper::purge_by_event('changesincoursecat');"})," to mark multiple caches as invalid at once without the calling code knowing which caches are affected."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"mappingsonly"}),": [bool] If set to true only the mapped cache store(s) will be used and the default mode store will not. This is a super advanced setting and should not be used unless absolutely required. It allows you to avoid the default stores for one reason or another."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"sharingoptions"}),": [int] The sharing options that are appropriate for this definition. Should be the sum of the possible options."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"defaultsharing"}),": [int] The default sharing option to use. It's highly recommended that you don't set this unless there is a very specific reason not to use the system default."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"localized-stores-for-distributed-high-performance-caching",children:"Localized stores for distributed high performance caching"}),"\n",(0,s.jsx)(t.p,{children:"Most cache definitions are simple in that the code expects to be able to purge the cache, or update it, and for this to be universally available from then on to all code which loads from this cache again. But as you scale up having a single mega shared cache store doesn't work well for a variety of reasons, including extra latency between multiple front ends and the shared cache service, the number of connections the cache server can handle, the cost of IO between services, and depending on the cache definition issues with locking while writing."}),"\n",(0,s.jsx)(t.p,{children:"So if you want very high performance caching then you need to write you code so that it can support being distributed, or localized, which means that each front end can have it's own independent cache store. But this architecture means that you have no direct way to communicate from code running in one place to invalidate the caches on all the other front ends. In order to achieve this you need to carefully construct cache keys so that if the content changes then it uses a new cache key, which will of course be a cache miss and then it will regenerate using fresh data. There are multiple ways to achieve this, a couple common example strategies are below."}),"\n",(0,s.jsx)(t.h3,{id:"when-should-you-localize",children:"When should you localize?"}),"\n",(0,s.jsxs)(t.p,{children:["Not all caches are good candidates to localize and some can have a detrimental effect if localized for the wrong reasons.\n",(0,s.jsx)(t.img,{alt:"When to localize a cache",src:i(43619).A+"",width:"734",height:"661"})]}),"\n",(0,s.jsx)(t.h3,{id:"revision-numbers-as-key-suffix",children:"Revision numbers as key suffix"}),"\n",(0,s.jsxs)(t.p,{children:["A simple method is storing a version number somewhere and appending that to your key. This is the most common method used in Moodle, simply store a number somewhere which is globally shared such as in a custom database field, or using ",(0,s.jsx)(t.code,{children:"set_config"})," / ",(0,s.jsx)(t.code,{children:"get_config"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"One small edge case with this approach is you now need to make sure that the incrementing code is atomic, which means you should use a DB transaction, or gain a lock, before bumping the version so you don't get two conflicting changes ending up on the same version with a race condition. However if you are anticipating high turnover rate of the cache you probably have a deeper issue, see 'Fast churning keys' below."}),"\n",(0,s.jsx)(t.p,{children:"One potential benefit of a simple version number strategy if your cache misses are very expensive, is that you can check for the presence of a version, and if it doesn't exist it is easy to simply retrieve the previous version and use it in the mean time, while you could generate the new version asynchronously. This is an advanced concept and depends on the use case and has the obvious disadvantage of showing stale data."}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsxs)(t.p,{children:["An example of this strategy in Moodle is the theme versions cache: ",(0,s.jsx)(t.a,{href:"https://github.com/moodle/moodle/blob/master/lib/outputlib.php#L88-L100",children:"https://github.com/moodle/moodle/blob/master/lib/outputlib.php#L88-L100"})]}),(0,s.jsx)(t.p,{children:"Note this is not actually in MUC but the caching concepts are the same."})]}),"\n",(0,s.jsx)(t.p,{children:"It works best with a cache store that supports Least Recently Used garbage collection."}),"\n",(0,s.jsx)(t.h3,{id:"revision-numbers-as-value-suffix-instead-of-key-suffix",children:"Revision numbers as value suffix instead of key suffix"}),"\n",(0,s.jsx)(t.p,{children:"This is conceptually the same as above but has two important differences. Firstly because the key itself is always the same then only a single version of some value will be stored on disk or in memory for any given cache store which makes it much more efficient in terms of storage. But secondly this comes with a higher coding complexity cost because it will no longer be guaranteed to be correct because a local cache could return a hit with a stale version. So if you need it to be correct you will need to parse out the revision from the value and then confirm the revision is correct before using the value. If it is invalid then you need to treat it as a miss and handle that. One way is to rebuild and set it, but this loses the advantage of primary and final caches (see below). A better way is to delete the local cache but not the final cache by passing a second param of false to delete, and then getting the value again which will repopulate the local cache from the shared cache:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:" $cache->delete('foo', false); // Delete the primary / local stale version\n $cache->get('foo');           // Get the final / shared version (which may also be stale!)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["But this also is imperfect if there are 3 layers of caching, see ",(0,s.jsx)(t.a,{href:"https://tracker.moodle.org/browse/MDL-72837",children:"MDL-72837"})," for a full discussion and a possible new api to handle this."]}),"\n",(0,s.jsx)(t.p,{children:"This method is how the course modinfo cache is localized."}),"\n",(0,s.jsx)(t.h3,{id:"using-time-as-a-key-suffix",children:"Using time as a key suffix"}),"\n",(0,s.jsxs)(t.p,{children:["Another common approach is to use a timestamp, this is how some of the core cache numbers work, see ",(0,s.jsx)(t.code,{children:"increment_revision_number()"})," for some examples. This has the benefit of not needing any transaction or locking, but you do run the risk of two processes clashing if they happen to run in the same second."]}),"\n",(0,s.jsxs)(t.p,{children:["It may look like Moodle theme-related caching uses this strategy, but actually if you look at ",(0,s.jsx)(t.a,{href:"https://github.com/moodle/moodle/blob/df0e58adb140f90712bcd3229ad936d3b4bc15d9/lib/outputlib.php#L88",children:"the code for theme_get_next_revision"}),", you will see that it is actually guaranteeing to generate a unique new integer which mitigates the clashing mentioned above. It is just making that integer close to current time-stamp, to make it more self-documenting."]}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://github.com/moodle/moodle/blob/master/lib/datalib.php#L1131-L1145",children:"https://github.com/moodle/moodle/blob/master/lib/datalib.php#L1131-L1145"})}),(0,s.jsx)(t.p,{children:"It works best with a cache store that supports Least Recently Used garbage collection."})]}),"\n",(0,s.jsx)(t.h3,{id:"content-hashes-as-keys",children:"Content hashes as keys"}),"\n",(0,s.jsxs)(t.p,{children:["A great strategy is to use a digest or hash such as ",(0,s.jsx)(t.code,{children:"sha1"})," / ",(0,s.jsx)(t.code,{children:"sha256"})," of the content stored inside the cache, or in even more advanced scenarios a hash of the dependencies of the content in the cache. This guarantees that the key will be unique, and can be truly distributed without any synchronous communication between the front ends."]}),"\n",(0,s.jsx)(t.p,{children:"This strategy can work very well when building up large cache items from many smaller cache fragments in a nested tree structure, eg when caching a structure which is built of other cache items, eg 10 chunks of html to get combined into a large chunk to be cached, you would append the 10 hashes of the 10 smaller chunks and then hash that to use as the key for the combined cache item. This means you can mutate a small part of a tree structure and quickly re-generate the whole tree without expensively regenerating all of the other branches and leaves in the tree."}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["This is known as 'Russian Doll' caching: ",(0,s.jsx)(t.a,{href:"https://blog.appsignal.com/2018/04/03/russian-doll-caching-in-rails.html",children:"https://blog.appsignal.com/2018/04/03/russian-doll-caching-in-rails.html"})]})}),"\n",(0,s.jsxs)(t.p,{children:["This is a very common strategy is many distributed systems, outside of the context of caching, and is conceptually how git works internally which is why commits are a ",(0,s.jsx)(t.code,{children:"sha1"})," hash."]}),"\n",(0,s.jsx)(t.p,{children:"This strategy works well if you may periodically change back and forth to previous states which will still be present and so be immediate hits without re-warming. It works best with a cache store that supports Least Recently Used garbage collection."}),"\n",(0,s.jsx)(t.h3,{id:"primary-and-final-caches",children:"Primary and Final caches"}),"\n",(0,s.jsx)(t.p,{children:"Because HTTP requests are generally assigned randomly or round-robin to front ends, when a cache item version changes you will now effectively have an empty cache on every front end. As you get the same cache item again and again on each front end it will continue to be a cache miss on each local box until they are all warm, which can ironically mean that on average for a fast-changing, but not often requested cache item, your cache hit rate will be very low and much worse than if you had a shared cache. The solution here is to have multiple levels of caches set up, a local cache backed by a shared cache. You do not need to do anything special in the code to support this if your cache is already localizable, the MUC manages this for you, ie if you request a key missing from the local cache it will then request it from the shared cache. If present it will copy it back to the local cache and then return the value. If it is not present in either then your fallback code will generate the item, and it will be written to both cache stores at the same time."}),"\n",(0,s.jsx)(t.p,{children:"This is especially important if you are scaling up and down the number of frontends quickly. If you suddenly need more horizontal scale and create a bunch of new front ends with empty caches and no shared cache they will all consume even more resources warming up and loading the shared services such as the database and filesystem."}),"\n",(0,s.jsxs)(t.p,{children:["A good rule of thumb is to pair similar types of local and shared caches together. For instance, it is very common to store the Moodle string cache in APCu because it is very heavily used, so an in-memory cache is the fastest and is well paired this a shared cache like Redis. ",(0,s.jsx)(t.code,{children:"coursemodinfo"})," on the other hand is often very large so isn't as practical to store in Redis so it is usually cached on disk, so you could have a local file cache (which could often be very fast ",(0,s.jsx)(t.code,{children:"SSD"}),") and pair it with a shared disk cache in ",(0,s.jsx)(t.code,{children:"dataroot"})," (often much slower over ",(0,s.jsx)(t.code,{children:"NFS"})," or ",(0,s.jsx)(t.code,{children:"Gluster"}),")."]}),"\n",(0,s.jsxs)(t.p,{children:["As you scale even bigger, a new bottleneck can appear when purging a shared disk cache ie when you deploy a new version. A full purge needs to iterate over and remove and sync a very large number of files, which can take some time. See ",(0,s.jsx)(t.a,{href:"https://tracker.moodle.org/browse/MDL-69088",children:"MDL-69088"})," for a proposed fix."]}),"\n",(0,s.jsx)(t.h3,{id:"beware-fast-churning-keys",children:"Beware fast churning keys"}),"\n",(0,s.jsx)(t.p,{children:"A big concern when designing a cache is how fast you anticipate it changing. If it contains very fast moving data but sparsely requested data (see above) then you can end up in a situation where you are effectively just using the shared final cache, and wasting latency and space and IO cloning data to the local cache where is may not be hit again very much. As always caching is a balancing act trading off between CPU, time and disk, and ultimately money."}),"\n",(0,s.jsx)(t.p,{children:"Even if your cache is able to use a local store that doesn't mean it actually will be configured to be local (and your code can't tell either way). So a wasteful cache item will consume much more space storing all the previous versions of its items even if it isn't localized, and it will be much worse if it is."}),"\n",(0,s.jsx)(t.h3,{id:"time-to-live-for-distributed-caches",children:"Time-To-Live for distributed caches"}),"\n",(0,s.jsx)(t.p,{children:"Another consideration is the total size of your cache stores across all the front ends. As cache keys change they are never be invalidated or purged. So you should have in place some process to garbage collect stale items. This is more a concern for the cache store implementations and the configuration but worth considering. Some stores are deleted on upgrade, or have a Time-To-Live or a Least Recently Used strategy for deleting stale items."}),"\n",(0,s.jsx)(t.h2,{id:"miscellaneous",children:"Miscellaneous"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Checkout important ",(0,s.jsx)(t.a,{href:"https://moodle.org/local/chatlogs/index.php?q=cache",children:"discussion about the Cache API at the Moodle developer chat"})]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},43619:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/When_to_localize_cache-f9a70c0ff95b3524ac076b51c5c6e258.png"}}]);